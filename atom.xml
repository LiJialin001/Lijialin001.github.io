<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wonderland</title>
  <icon>https://www.gravatar.com/avatar/9678facf9f7cbd47edda50e4c5418b27</icon>
  
  <link href="http://wonderland.plus/atom.xml" rel="self"/>
  
  <link href="http://wonderland.plus/"/>
  <updated>2022-11-23T12:29:37.997Z</updated>
  <id>http://wonderland.plus/</id>
  
  <author>
    <name>A.S.</name>
    <email>lijialin_3737@icloud.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微机原理总结</title>
    <link href="http://wonderland.plus/posts/7427/"/>
    <id>http://wonderland.plus/posts/7427/</id>
    <published>2022-11-17T11:15:11.903Z</published>
    <updated>2022-11-23T12:29:37.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8086寄存器结构"><a href="#8086寄存器结构" class="headerlink" title="8086寄存器结构"></a>8086寄存器结构</h1><h2 id="通用寄存器组"><a href="#通用寄存器组" class="headerlink" title="通用寄存器组"></a>通用寄存器组</h2><table><thead><tr><th align="center">AH</th><th align="center">AL</th><th align="center">AX</th><th align="center">累加器</th></tr></thead><tbody><tr><td align="center">BH</td><td align="center">BL</td><td align="center">BX</td><td align="center">基数</td></tr><tr><td align="center">CH</td><td align="center">CL</td><td align="center">CX</td><td align="center">计数</td></tr><tr><td align="center">DH</td><td align="center">DL</td><td align="center">DX</td><td align="center">数据</td></tr></tbody></table><table><thead><tr><th align="center">SP</th><th align="center">堆栈指针</th></tr></thead><tbody><tr><td align="center">BP</td><td align="center">基址指针</td></tr><tr><td align="center">SI</td><td align="center">源变址</td></tr><tr><td align="center">DI</td><td align="center">目的变址</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th align="center">IP</th><th align="center"></th><th align="center">指令指针</th></tr></thead><tbody><tr><td align="center">FH</td><td align="center">FL</td><td align="center">状态标志</td></tr></tbody></table><table><thead><tr><th align="center">CS</th><th align="center">代码段寄存器</th></tr></thead><tbody><tr><td align="center">DS</td><td align="center">数据段寄存器</td></tr><tr><td align="center">SS</td><td align="center">堆栈段寄存器</td></tr><tr><td align="center">ES</td><td align="center">附加段寄存器</td></tr></tbody></table><h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><h2 id="一些默认"><a href="#一些默认" class="headerlink" title="一些默认"></a>一些默认</h2><ul><li>执行指令后，dst中存放运算结果</li><li>一个单元（nn）给字时，为nn和nn+1</li></ul><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p><strong>寻得操作数来源</strong></p><ol><li><p>固定寻址</p><p>操作数地址被隐含于操作码中，无需计算EA</p></li><li><p>立即数寻址</p><p>操作数直接放在指令字段中，执行时直接从此读取</p><blockquote><p>显然，由于其无法存放运算结果，故只能作为原操作数使用</p></blockquote></li><li><p>寄存器寻址</p><p>使用CPU内部寄存器中数据作为操作数</p><p>CPU内部执行，无需总线周期</p></li><li><p>存储器寻址</p><p>一般位于DS、SS、ES中，需EU计算出EA，再由BIU计算出PA，通过PA取得操作数</p><p>src和dst只能有一个为存储器操作数</p><ul><li><p>直接寻址</p><p>直接给出EA(nn)</p><p>?S: [nn]</p><p>段首址缺省值DS</p></li><li><p>寄存器间接寻址</p><p>EA于寄存器(BX\SI\DI\BP)中，其中BX、SI、DI段首址缺省DS，BP缺省SS</p></li><li><p>寄存器相对寻址</p><p>加上偏移量</p><p>AREA[SI] </p><p>缺省同上</p></li><li><p>基址变址寻址</p><p>基址加上变址，缺省同上</p></li><li><p>相对基址加变址寻址</p><p>超级加倍</p></li><li><p>串寻址</p><p>隐含使用SI(指向源串首字)、DI</p><p>SB或SW(字串)</p></li><li><p>32为寻址</p><p>变址乘了一个比例系数，其他不变，寄存器名称变(前面加个E)</p></li></ul></li><li><p>I&#x2F;O端口寻址</p><ul><li><p>直接端口寻址</p><p>端口数0～255</p></li><li><p>寄存器间接端口寻址</p><p>端口数大于255的，放在一寄存器中转借一下</p></li></ul></li></ol><h2 id="8086指令系统"><a href="#8086指令系统" class="headerlink" title="8086指令系统"></a>8086指令系统</h2><table><thead><tr><th>im</th><th>立即数</th></tr></thead><tbody><tr><td>reg</td><td>寄存器</td></tr><tr><td>seg</td><td>段寄存器</td></tr><tr><td>m</td><td>存储单元</td></tr></tbody></table><p><em>CS、IP两个寄存器不做dst</em></p><h3 id="Data-Transfer"><a href="#Data-Transfer" class="headerlink" title="Data Transfer"></a>Data Transfer</h3><p><strong>通用传输</strong></p><table><thead><tr><th align="left">MOV</th><th align="center">im到seg、seg到seg、m到m🙅</th></tr></thead><tbody><tr><td align="left">XCHG</td><td align="center">交换两操作数内容，im、seg🙅，必有一个reg</td></tr><tr><td align="left">PUSH</td><td align="center">用于程序保护，不对字节操作（对字，高位先入</td></tr><tr><td align="left">POP</td><td align="center">用于恢复数据，同上（SP自动加2</td></tr></tbody></table><p><strong>累加器专用</strong></p><table><thead><tr><th>IN</th><th align="center">只能用于AX&#x2F;AL，tx</th></tr></thead><tbody><tr><td>OUT</td><td align="center">中间寄存器只能使用DX，ts</td></tr><tr><td>XLAT</td><td align="center">（BX+AL）➡️ AL，可用于查表</td></tr></tbody></table><p><strong>地址-目标传送</strong></p><table><thead><tr><th>LEA  reg  src</th><th align="center">src的EA ➡️ reg</th></tr></thead><tbody><tr><td>LDS  reg  src</td><td align="center">src的(EA+2) ➡️ DS、src的EA ➡️ reg</td></tr><tr><td>LES</td><td align="center">与LDS类似</td></tr></tbody></table><p><strong>标志寄存器传送</strong></p><table><thead><tr><th>LAHF</th><th align="center">Load AH from Flags, 标志位第八位读到AH</th></tr></thead><tbody><tr><td>SAHF</td><td align="center">与上反</td></tr><tr><td>PUSHF</td><td align="center">标志寄存器入栈</td></tr><tr><td>POPF</td><td align="center"></td></tr></tbody></table><h3 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h3><p>scr和dst必须有一个为reg（scr为im的情况除外</p><p>8位无符号数 0～255（FFH（显然16位到FFFF H</p><p>显然8位有符号数（80H～7FH即 -128～ +127）、16位 8000H ～ 7FFFH</p><blockquote><p>加减法两个操作数必同为无符号OR有符号</p></blockquote><p>组合BCD：一字节两位                非组合BCD：一字节第四位表示一位</p><p>除INC指令不影响CF外，其余均影响CF、OF等六个标志位</p><p>调整指令要求操作数为 B， 其他B、W均可</p><p><strong>标志位变化</strong></p><table><thead><tr><th>CF</th><th align="center">无符号溢出</th><th>OF</th><th align="center">有符号溢出❌</th><th>ZF</th><th align="center">运算结果为0时置1</th></tr></thead><tbody><tr><td>SF</td><td align="center">运算结果为负置1</td><td>PF</td><td align="center">运算结果有偶数个1，置1</td><td>AF</td><td align="center">操作数为BCD，半字节进位，置1</td></tr></tbody></table><p><strong>加法</strong></p><table><thead><tr><th>ADD</th><th align="center">双精度字先低位ADD，后高位ADC</th></tr></thead><tbody><tr><td>ADC</td><td align="center">带进位，加上CF</td></tr><tr><td>INC</td><td align="center">修改指针OR循环计数（不修改CF故不用于控制循环结束</td></tr><tr><td>AAA</td><td align="center">对非组合BCD调整，结果分为AH、AL存入AX</td></tr><tr><td>DAA</td><td align="center">组合BCD十进制调整，若超范围则加6调整，默认在AL中进行</td></tr></tbody></table><p><strong>减法</strong></p><table><thead><tr><th>SUB</th><th align="center">无借位</th></tr></thead><tbody><tr><td>SBB</td><td align="center">将低位借的CF减去</td></tr><tr><td>DEC</td><td align="center">同INC对CF无影响</td></tr><tr><td>NEG</td><td align="center">求补码（0-src）➡️ src 即 （FFH - src）➡️ src，显然src不为0时使CF &#x3D; 1</td></tr><tr><td>CMP</td><td align="center">相减，但结果不送dst，只更改标志位</td></tr><tr><td>AAS</td><td align="center">非组合十进制调整，-6</td></tr><tr><td>DAS</td><td align="center">组合十进制调整</td></tr></tbody></table><p><strong>乘法</strong></p><table><thead><tr><th>MUL  src(B or W)</th><th align="center">AL*src ➡️ AX 或  AX *src ➡️ DX,AX，无符号</th></tr></thead><tbody><tr><td>IMUL src</td><td align="center">同上，有符号</td></tr><tr><td>AAM</td><td align="center">非组合十进制调整，组合无法调整</td></tr></tbody></table><p><strong>除法</strong></p><table><thead><tr><th>DIV   src</th><th align="center">AX&#x2F;src ➡️ AL   DX,AX&#x2F;src ➡️ AX  余数➡️AH 或 DX</th></tr></thead><tbody><tr><td>IDIV  src</td><td align="center"></td></tr><tr><td>AAD</td><td align="center">非组合十进制调整，组合无法调整</td></tr><tr><td>CBW</td><td align="center">AL按<strong>符号</strong>拓展为AX, AL&lt;80H➡️AH&#x3D;00H 反之AH&#x3D;FFH</td></tr><tr><td>CWD</td><td align="center">AX ➡️ DX,AX，按符号拓展</td></tr></tbody></table><h3 id="Logic-and-Shift"><a href="#Logic-and-Shift" class="headerlink" title="Logic and Shift"></a>Logic and Shift</h3><p>操作数类型均可B 或 W</p><p><strong>布尔型指令</strong></p><table><thead><tr><th>AND</th><th align="center">可用于对指定位屏蔽(清零)</th></tr></thead><tbody><tr><td>OR</td><td align="center">可用于对特定位置1</td></tr><tr><td>XOR</td><td align="center">可通过查看ZF比较操作数是否相同</td></tr><tr><td>TEST</td><td align="center">与AND类似，只影响标志位</td></tr><tr><td>NOT</td><td align="center">取反码</td></tr><tr><td>技巧</td><td align="center">AND AX,AX   OR AX,AX   XOR AX,AX 都可清CF，但XOR同时清AX<br /> TEST AL，01H  可检测AL为奇&#x2F;偶</td></tr></tbody></table><p><strong>移位</strong></p><table><thead><tr><th>SHL&#x2F;SAL</th><th align="center">低位补0，原高位进CF，高位不等于CF➡️OF&#x3D;1则符号改变</th></tr></thead><tbody><tr><td>SHR</td><td align="center">高位补0，原低位进CF</td></tr><tr><td>SAR</td><td align="center">原高位补高位，低位进CF</td></tr><tr><td>ROL</td><td align="center">原高位进CF且补低位</td></tr><tr><td>ROR</td><td align="center">原低位进CF且补高位</td></tr><tr><td>RCL</td><td align="center">原高位进CF，原CF补低位</td></tr><tr><td>RCR</td><td align="center">原低位进CF，原CF补高位</td></tr><tr><td>技巧</td><td align="center">循环指令通过每次检测CF可以判断reg&#x2F;meg含1或0的个数</td></tr></tbody></table><h3 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h3><p><strong>串操作使用的寄存器</strong></p><table><thead><tr><th>SI</th><th align="center">源字符串变址寄存器</th></tr></thead><tbody><tr><td>DI</td><td align="center">目的字符串变址寄存器</td></tr><tr><td>CX</td><td align="center">重复操作次数计数器</td></tr><tr><td>AL&#x2F;AX</td><td align="center">SCAS扫描值、LODS的dst、STOS的src</td></tr><tr><td>DF</td><td align="center">等于0➡️SI、DI自动加1(2)；等于1 减</td></tr><tr><td>ZF</td><td align="center">扫描、比较串操作终止标志</td></tr></tbody></table><table><thead><tr><th>MOVS&#x2F;MOVSB&#x2F;MOVSW</th><th align="center">串传送，要提前将串的变址以及传送长度存入对应reg</th></tr></thead><tbody><tr><td>CMPS&#x2F;CMPSB&#x2F;CMPSW</td><td align="center">串比较，根据ZF判断结果(减法)</td></tr><tr><td>SCAS&#x2F;SCASB&#x2F;SCASW</td><td align="center">串搜索，在DI所指串中搜索AL(AX)，判断同上</td></tr><tr><td>LODS&#x2F;LODSB&#x2F;LODSW</td><td align="center">把SI所指串取到AL(AX)中，显然无法使用重复前缀</td></tr><tr><td>STOS&#x2F;STOSB&#x2F;STOSW</td><td align="center">存串指令</td></tr><tr><td>REP&#x2F;REPZ&#x2F;REPE&#x2F;REPNE&#x2F;REPNZ</td><td align="center">CX&#x3D;0时退出；REPZ&#x2F;REPE附加ZF条件，等于0提前退出；REPNE&#x2F;REPNZ同理</td></tr></tbody></table><h3 id="Control-Jump"><a href="#Control-Jump" class="headerlink" title="Control Jump"></a>Control Jump</h3><p>原理：改变CS与IP</p><p><strong>无条件转移、调用、返回</strong></p><p>段内转移，目标为NEAR类，近转移，改IP；    段间转移，目标为FAR类，远转移，改CS和IP</p><table><thead><tr><th>JMP</th><th align="center">可段内直接寻址(JMP NAME PTR TAGET或JMP SHORT OBJECT)<br />可段内间接寻址(JMP reg或JMP WORD PTR[SI])<br />可段间直接寻址(JMP FAR PTR LABEL, LABEL为转移地址号)<br />可段间间接寻址(JMP DWORD PTR[BX] [SI])</th></tr></thead><tbody><tr><td>CALL</td><td align="center">调用格式同上<br />多了保存的功能，分四步<br />1⃣️ (SP-2)➡️SP；CS ➡️((SP+1),(SP))<br />2⃣️SEG➡️CS<br />3⃣️(SP-2)➡️SP；IP ➡️((SP+1),(SP))<br />4⃣️dst➡️IP</td></tr><tr><td>RET</td><td align="center">恢复栈即SP+4，后面可加立即数加到SP，过程与上面相反</td></tr></tbody></table><p><strong>条件转移指令</strong></p><p>JCC Target 若CC成立则跳转到target</p><p>无N时J后两字符为或关系，有N后面字符为与关系</p><table><thead><tr><th>A</th><th>above</th></tr></thead><tbody><tr><td>B</td><td>below</td></tr><tr><td>C</td><td>carry</td></tr><tr><td>E</td><td>equal</td></tr><tr><td>Z</td><td>zore（ZF）</td></tr><tr><td>G</td><td>greater(有符号)</td></tr><tr><td>L</td><td>less</td></tr><tr><td>O</td><td>overflow(OF)</td></tr><tr><td>P</td><td>parity(奇偶位PF)</td></tr><tr><td>CXZ</td><td>CX is zero</td></tr><tr><td>s</td><td>sign</td></tr></tbody></table><p><strong>循环控制指令</strong></p><p>以CX为计数器，CX不等于0时相当于执行(IP+8)➡️IP</p><table><thead><tr><th>LOOP</th><th align="center">JNZ？？？</th></tr></thead><tbody><tr><td>LOOPZ&#x2F;LOOPE</td><td align="center">CX&#x3D;0或ZF&#x3D;0均可退出循环</td></tr><tr><td>LOOPNZ&#x2F;LOOPNE</td><td align="center">CX&#x3D;0且ZF&#x3D;0退出循环</td></tr></tbody></table><h3 id="Processor-Control"><a href="#Processor-Control" class="headerlink" title="Processor Control"></a>Processor Control</h3><p><strong>状态标志位操作指令</strong></p><table><thead><tr><th>CF</th><th>进位标志位</th><th>DF</th><th>方向标志位</th><th>IF</th><th>中断标志位</th></tr></thead></table><table><thead><tr><th>CLC</th><th align="center">CF置0</th></tr></thead><tbody><tr><td>CMC</td><td align="center">CF取反</td></tr><tr><td>STC</td><td align="center">CF置1</td></tr><tr><td>CLD    控制串操作执行（方向</td><td align="center">DF置0</td></tr><tr><td>STD    同上</td><td align="center">DF置1</td></tr><tr><td>CLI      禁止CPU响应</td><td align="center">IF置0</td></tr><tr><td>STI      允许</td><td align="center">IF置1</td></tr></tbody></table><p><strong>外部同步指令</strong></p><table><thead><tr><th>HLF</th><th align="center">停机等待外部中断 OR 复位</th></tr></thead><tbody><tr><td>WAIT</td><td align="center">CPU空转状态等待外部中断，完成后返回空转</td></tr><tr><td>ESC OPC ，src</td><td align="center">协处理器相关</td></tr><tr><td>LOCK</td><td align="center">总线封锁前缀，使LOCK&#x3D;0</td></tr></tbody></table><p><strong>空操作指令</strong></p><table><thead><tr><th>NOP</th><th align="center">占3个时钟周期</th></tr></thead></table><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><p><strong>中断及终端返回指令</strong></p><table><thead><tr><th>INT n</th><th align="center">n为中断类型号<br />F、CS、IP入栈，TF、IF清0<br />取入口偏移地址存入CS、IP</th></tr></thead><tbody><tr><td>IRET</td><td align="center">中断返回指令，F、CS、IP出栈</td></tr></tbody></table><p><strong>专用中断</strong></p><table><thead><tr><th>0</th><th>除数为0时响应</th><th>1</th><th>单步中断，触发条件TF&#x3D;1</th><th>2</th><th>紧急非屏蔽中断NMI</th><th>3</th><th>断点中断，INT指令触发</th><th>4</th><th>溢出中断，INTO指令触发</th></tr></thead></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(.asm源程序)--&gt;B(汇编程序)--&gt;C(.obj/.lst)</span><br></pre></td></tr></table></figure><p>使用：<strong>MASM宏汇编</strong></p><h1 id="MASM宏汇编语言规范"><a href="#MASM宏汇编语言规范" class="headerlink" title="MASM宏汇编语言规范"></a>MASM宏汇编语言规范</h1><h3 id="分段结构"><a href="#分段结构" class="headerlink" title="分段结构"></a>分段结构</h3><ul><li>对应CPU内存分段管理</li><li>每段有名字且以伪指令 <strong>SEGMENT</strong> 开始，以 <strong>ENDS</strong> 结束</li><li>源程序由若干段组成，以 <strong>END</strong> 结束</li></ul><h3 id="语句构成"><a href="#语句构成" class="headerlink" title="语句构成"></a>语句构成</h3><p><strong>语句类型</strong></p><ul><li>指令语句，以助记符为基础</li><li>伪指令语句，管理性，不产生机器代码</li><li>宏指令语句</li></ul><p><strong>构成与规范</strong></p><ul><li><p>名字域：</p><ul><li>由字母开头，可包含数字和专有字符</li><li>指令语句名字后跟冒号，伪指令无</li></ul></li><li><p>操作符域：</p><ul><li>主要为助记符</li></ul></li><li><p>操作数域：</p><ul><li><p>逗号分隔</p></li><li><p>存储器操作数</p><ul><li>标号：指令语句的名字域，可认为是指令语句的地址</li><li>变量：存放在某存储单元的数据，变量符号的地址</li></ul></li><li><p>表达式：由以上以及运算符组合而成</p></li><li><p>运算符</p><ul><li><p>算数运算符：完成整数的运算，结果为整数</p><table><thead><tr><th>+、-、*、&#x2F;</th><th>MOD(求余)、SHL、SHR</th></tr></thead></table></li><li><p>逻辑运算符</p></li><li><p>关系运算符</p><table><thead><tr><th>EQ</th><th>相等</th><th>NE</th><th>不等</th><th>LT</th><th>小于</th><th>GT</th><th>大于</th><th>LE</th><th>小于等于</th><th>GE</th><th>大于等于</th></tr></thead></table></li><li><p>分析运算符</p><table><thead><tr><th>SEG</th><th>求段基址</th><th>OFFEST</th><th>求偏移量</th><th>TYPE</th><th>求变量类型</th><th>SIZE</th><th>求字节数</th><th>LENGTH</th><th>求变量长度</th></tr></thead></table><p>TYPE类型值</p><table><thead><tr><th>1</th><th>2</th><th>4</th><th>-1</th><th>-2</th></tr></thead><tbody><tr><td>DB</td><td>DW</td><td>DD</td><td>NEAR</td><td>FAR</td></tr></tbody></table></li><li><p>综合运算符</p><p>为存储器地址操作数临时指定一个新属性</p><table><thead><tr><th>PTR</th><th align="center">将左边类型指定给右边地址</th></tr></thead><tbody><tr><td>THIS</td><td align="center">类似上；与下一条指令分配的段、偏移、属性相同</td></tr></tbody></table></li></ul></li></ul></li></ul><h1 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h1><h4 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h4><p>DB～DD、DQ、DT</p><p>重复操作符 DUP  [变量名] DB 100 DUP(?)   ？表示不设初值（随机</p><h4 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a><strong>符号定义</strong></h4><table><thead><tr><th>EQU</th><th align="center">类似于C中#define，不允许重复定义</th></tr></thead><tbody><tr><td>&#x3D;</td><td align="center">允许重复定义</td></tr></tbody></table><h4 id="段定义"><a href="#段定义" class="headerlink" title="段定义"></a>段定义</h4><p>段名  <strong>SEGMENT</strong>  [定位类型] [组合类型] [‘类别’]</p><p>​          段内语句</p><p>段名  <strong>ENDS</strong></p><ul><li>定位类型：起始边界要求 缺省值PARA </li><li>组合类型：表示与其他段关系  缺省值NONE</li><li>类别：一种名字信息</li></ul><h4 id="段寻址ASSUME"><a href="#段寻址ASSUME" class="headerlink" title="段寻址ASSUME"></a>段寻址ASSUME</h4><p>用来设定各段名与 段寄存器间关系  格式：<strong>ASSUME</strong> 段寄存器名 :  段名 ， 段寄存器名 :  段名 ……</p><p>没有给出初值，需和初始化代码配合使用；CS段首址无需初值，系统自动设置</p><h4 id="过程定义-PROC-x2F-ENDP"><a href="#过程定义-PROC-x2F-ENDP" class="headerlink" title="过程定义 PROC&#x2F;ENDP"></a>过程定义 PROC&#x2F;ENDP</h4><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过程名PROC[NEAR]/FAR(属性)</span><br><span class="line">代码</span><br><span class="line">RET(应为过程中最后执行的语句)</span><br><span class="line">代码</span><br><span class="line">过程名ENDP</span><br></pre></td></tr></table></figure><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器 $"></a>程序计数器 $</h4><p>$的值为程序下一所能分配存储单元的偏移地址</p><h4 id="定位伪指令-ORG"><a href="#定位伪指令-ORG" class="headerlink" title="定位伪指令 ORG"></a>定位伪指令 ORG</h4><p>指定下一条语句的 偏移地址</p><h4 id="结构伪指令"><a href="#结构伪指令" class="headerlink" title="结构伪指令"></a>结构伪指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">结构名STRUC</span><br><span class="line">内容</span><br><span class="line">结构名ENDS</span><br><span class="line"></span><br><span class="line">预置：</span><br><span class="line">结构变量名结构名&lt;字段值表&gt;</span><br><span class="line"></span><br><span class="line">引用：</span><br><span class="line">结构变量名.结构字段名</span><br><span class="line">[地址寄存器].结构字段名</span><br></pre></td></tr></table></figure><h4 id="记录伪指令"><a href="#记录伪指令" class="headerlink" title="记录伪指令"></a>记录伪指令</h4><p>记录共1～2字节，可为每个字段分配二进制位数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">记录名RECORD&lt;字段名&gt;: 宽度[= 表达式][,...]</span><br><span class="line">预置：</span><br><span class="line">记录变量名记录名&lt;字段值表，以B结尾，逗号隔开&gt;</span><br><span class="line">记录运算符：</span><br><span class="line">WIDTH记录名/记录字段名；求出记录/记录字段所占位数</span><br><span class="line">MASK记录字段名；一个记录字段在记录中占拿几位（以出现1为标记</span><br><span class="line">记录字段名单独出现：代表其移到记录最右端所需位数</span><br><span class="line">MOVAH，20HSHL AD；AH = 20 SHL 1 = 40H</span><br></pre></td></tr></table></figure><h4 id="宏相关"><a href="#宏相关" class="headerlink" title="宏相关"></a>宏相关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">宏定义：</span><br><span class="line">宏指令名MACRO&lt;形式参数1&gt;,&lt;形式参数2&gt;,... ；也可不设参数</span><br><span class="line">语句组</span><br><span class="line">          ENDM</span><br><span class="line">宏调用：</span><br><span class="line">直接当语句用，有参数后面跟参数，逗号隔开</span><br><span class="line">取消：</span><br><span class="line">PURGE&lt;宏指令名1&gt;，&lt;宏指令名2&gt;，&lt;宏指令名3&gt;，...</span><br></pre></td></tr></table></figure><h4 id="系统调用功能"><a href="#系统调用功能" class="headerlink" title="系统调用功能"></a>系统调用功能</h4><p>见PDF</p><h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h2 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>按读写功能：RWM、ROM （只写、只读</p></li><li><p>按存取方式：DAM、SAM、RAM  （直接存取、顺序存取、随机存取</p></li><li><p>按器件分类：双极性TTL、单极性MOS</p><blockquote><p>双极性快、功率大、集成度低</p><p>单极性相反</p></blockquote></li><li><p>按存储原理：RAM、ROM</p><blockquote><p>RAM可读可写、断电丢失</p><p>ROM正常只读、断电不丢失</p></blockquote></li><li><p>按数据传送方式：并行、串行</p></li></ul><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>存储容量</li><li>存取时间</li><li>功耗</li><li>工作电源<ul><li>TTL +5V</li><li>MOS +3～+18V</li></ul></li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>存储体</li><li>地址译码器</li><li>控制逻辑电路</li><li>数据缓冲器</li></ul><h3 id="高速缓存工作原理"><a href="#高速缓存工作原理" class="headerlink" title="高速缓存工作原理"></a>高速缓存工作原理</h3><ul><li>依赖：<ul><li>程序访问的局部性</li><li>数据相对集中存储</li><li>把频繁访问的指令、数据存放在速度非常高 (与CPU速度相当)的SRAM——高速缓存 CACHE中</li></ul></li><li>取指令、数据时先到CACHE中查找，没找到再到RAM找</li><li>系统的平均存取速度(加权平均) ≈ Cache存取速度×命中率+RAM存取速度×不命中率 </li><li>Cache与内存的空间比一般为1:128。</li></ul><h3 id="存储器寻址方法"><a href="#存储器寻址方法" class="headerlink" title="存储器寻址方法"></a>存储器寻址方法</h3><p><strong>片选</strong>：根据主存储器 系统对每个存储器芯片的地址范围的分配</p><p><strong>字选</strong>：选中存储器芯片片内存储单元，由芯片内地译码电路完成</p><h1 id="I-x2F-O接口"><a href="#I-x2F-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h1><h2 id="I-x2F-O组成"><a href="#I-x2F-O组成" class="headerlink" title="I&#x2F;O组成"></a>I&#x2F;O组成</h2><h4 id="接向CPU"><a href="#接向CPU" class="headerlink" title="接向CPU"></a>接向CPU</h4><ul><li><p>总线驱动器：匹配CPU数据总线速度和驱动能力</p></li><li><p>地址译码器：接收CPU总线信号并译码，对各端口(reg)寻址</p></li><li><p>控制逻辑：实现CPU对端口读写操作和时序控制</p></li></ul><h4 id="接向外设"><a href="#接向外设" class="headerlink" title="接向外设"></a>接向外设</h4><ul><li>缓冲器（数据reg）</li><li>控制reg：存放CPU控制命令</li><li>状态reg：保存状态以供CPU查询</li></ul><h2 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><h4 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h4><ul><li>无条件传送（同步传送<ul><li>条件：外设必须随时准备就绪</li></ul></li><li>条件传送（查询传送<ul><li>先查询外设工作状态，在外设就绪后进行数据输入、输出</li></ul></li></ul><h4 id="DMA控制"><a href="#DMA控制" class="headerlink" title="DMA控制"></a>DMA控制</h4><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p><strong>三大用途</strong>：分时操作、实时处理、故障处理</p><h4 id="可屏蔽中断（IF-x3D-0时屏蔽"><a href="#可屏蔽中断（IF-x3D-0时屏蔽" class="headerlink" title="可屏蔽中断（IF&#x3D;0时屏蔽"></a>可屏蔽中断（IF&#x3D;0时屏蔽</h4><p>使IF&#x3D;0情况：</p><ul><li><p>关中断、禁止中断、中断屏蔽</p></li><li><p>系统复位，使<strong>IF</strong>&#x3D;<strong>0</strong> </p></li><li><p>任何一个中断被响应，使<strong>IF</strong>&#x3D;<strong>0</strong> </p></li><li><p>执行指令<strong>CLI</strong>，使<strong>IF</strong>&#x3D;<strong>0</strong></p></li></ul><p>使IF&#x3D;1情况：</p><ul><li>开中断、允许中断、中断开放 </li><li>执行指令<strong>STI</strong>，使<strong>IF</strong>&#x3D;<strong>1</strong></li></ul><p><strong>中断向量在中断向量表中的位置称为中断向量地址；</strong></p><p><strong>中断向量地址&#x3D;中断类型号×4</strong></p><p>中断子程序使用<strong>IRET</strong>指令返回</p><h1 id="8259A芯片"><a href="#8259A芯片" class="headerlink" title="8259A芯片"></a>8259A芯片</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ul><li>中断请求寄存器<strong>IRR(8</strong>位)<ul><li>保存<strong>8</strong>条外界中断请求信号<strong>IR0</strong>~<strong>IR7</strong>的请求状态</li><li><strong>Di</strong>位为<strong>1</strong>表示<strong>IRi</strong>引脚有中断请求</li></ul></li><li>中断服务寄存器<strong>ISR</strong>(<strong>8</strong>位)<ul><li>保存正在被<strong>8259A</strong>服务着的中断状态</li><li><strong>Di</strong>位为<strong>1</strong>表示<strong>IRi</strong>中断正在服务中;为<strong>0</strong>表示没有被服务(处理完毕)</li></ul></li><li>中断屏蔽寄存器<strong>IMR</strong>(<strong>8</strong>位)<ul><li>保存<strong>CPU</strong>送来的对中断请求信号<strong>IR</strong>的屏蔽状态</li><li><strong>Di</strong>位为<strong>1</strong>表示<strong>IRi</strong>中断被屏蔽(禁止)</li></ul></li></ul><h2 id="优先级分析器PR"><a href="#优先级分析器PR" class="headerlink" title="优先级分析器PR"></a>优先级分析器<strong>PR</strong></h2><ul><li>定义和修改<strong>IR0-IR7</strong>的优先级别 (通常<strong>IR0</strong>为高，<strong>IR7</strong>为最低)</li><li>同时出现几个中断请求时，根据 优先级别决定处理哪一个</li><li>处理中断嵌套</li></ul><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><ol><li><p>执行一段<strong>CPU</strong>的初始化程序， 向<strong>8259</strong>写命令字，规定<strong>8259</strong>的工作状态（初始化</p></li><li><p>中断源通过<strong>IR0</strong>~<strong>IR7</strong>向<strong>8259A</strong>发中断请求，<strong>8259A</strong>中断请求寄存器<strong>IRR</strong>的相应位置<strong>1</strong></p></li><li><p><strong>IRR</strong>中经中断屏蔽寄存器<strong>IMR</strong>允许后的置位 进入优先权判别器<strong>PR</strong></p><p><strong>PR</strong>将其中最高优先权的中断请求经控制逻辑向<strong>CPU</strong>发<strong>INT</strong>(高电平)请求</p></li><li><p>若 <strong>CPU</strong> 处于开中断状态 (<strong>IF&#x3D;1</strong>)，在当前指令执行结束后，启动中断响应总线操作（发出两个负脉冲作为响应信号）</p></li><li><p><strong>8259A</strong>接收到第一个负脉冲</p><ul><li>使<strong>ISR</strong>相应位置<strong>1</strong>，表示<strong>CPU</strong>已为该中断请求服务</li><li>使<strong>IRR</strong>的相应位清<strong>0</strong>(防止一次申请的重复处理)</li></ul></li><li><p><strong>8259A</strong>接收到第二个负脉冲</p><ul><li><p>将中断类型号送上数据总线（中断类型号由用户编程和中断请求引脚<strong>IRi</strong>的序号<strong>i</strong>共同决定）</p></li><li><p><strong>CPU</strong>读取中断类型号（经响应过程后）进入中断服务程序，直到服务结束返回。</p></li><li><p><strong>CPU</strong>向<strong>8259A</strong>送中断结束命令作为中断结束标志</p></li></ul></li><li><p>若工作在<strong>AEOI</strong>方式：在第<strong>2</strong>个<strong>INTA#<strong>结束时使</strong>ISRi</strong>复位;    否则由<strong>CPU</strong>发出<strong>EOI</strong>命令使<strong>ISR</strong> <strong>i</strong>复位</p></li></ol><h2 id="工作方式（5方面）"><a href="#工作方式（5方面）" class="headerlink" title="工作方式（5方面）"></a>工作方式（5方面）</h2><ul><li>中断优先方式与中断嵌套（各两种</li><li>中断结束处理方式 （三种EOI命令</li><li>屏蔽中断源的方式 （两种</li><li>中断触发方式（两种</li><li>级联工作方式</li></ul><p>通过初始化命令字 (<strong>ICW1</strong><del><strong>ICW4</strong>) 和操作命令字 (<strong>OCW1</strong></del><strong>OCW4</strong>) 设置</p><h3 id="中断优先方式与中断嵌套"><a href="#中断优先方式与中断嵌套" class="headerlink" title="中断优先方式与中断嵌套"></a>中断优先方式与中断嵌套</h3><ul><li>中断优先方式<ul><li>固定优先级<ul><li>所有中断请求<strong>IRi</strong>的中断优先级固定不变</li><li>优先级排列顺序可编程改变</li><li>默认优先级顺序从高到低为<strong>IR0~IR7</strong></li></ul></li><li>循环优先级方式<ul><li>自动中断优先级循环，初始优先级顺序可用编程改变</li><li>中断请求<strong>IRi</strong>被处理后，其优先级别自动降为最低， 原来比它低一级的中断上升为最高级</li></ul></li></ul></li><li>中断嵌套（中断处理过程中被更高优先级中断）方式<ul><li>普通全嵌套方式(默认<ul><li>中断被处理时，只有更高优先级中断可打断</li></ul></li><li>特殊全嵌套方式<ul><li>允许同级或更高优先级打断</li><li>仅用于多个<strong>8259A</strong>级连时的主<strong>8259A</strong></li></ul></li></ul></li></ul><h3 id="中断结束处理方式"><a href="#中断结束处理方式" class="headerlink" title="中断结束处理方式"></a>中断结束处理方式</h3><ul><li><strong>IRi</strong>中断被服务时，<strong>ISR</strong>中的相应位 <strong>ISRi</strong>&#x3D;1，结束后必须清零该位</li><li>通过向8259A发出中断结束命令 (EOI命令)使<strong>ISRi</strong>&#x3D;0（中断结束处理</li><li>三种<strong>EOI</strong>命令<ul><li>自动<strong>EOI</strong>(<strong>AEOI</strong>)<ul><li>第<strong>2</strong>个<strong>INTA#<strong>结束时，由</strong>8259A</strong>使 <strong>ISRi</strong>自动复位</li><li>不用于中断嵌套方式（不保留当前正在服务的中断的状态</li></ul></li><li>普通中断结束方式<strong>EOI</strong>(<strong>NSEOI</strong>)<ul><li>由<strong>CPU</strong>发出正常<strong>EOI</strong>命令</li><li>使<strong>ISRi&#x3D;1</strong>的位中优先级最高的那一位复位</li></ul></li><li>特殊中断结束方式<strong>EOI</strong>(<strong>SEOI</strong>)<ul><li>由<strong>CPU</strong>发出一条<strong>SEOI</strong>命令，指出所要复位的<strong>ISR</strong>的位号</li><li>用于特殊屏蔽方式</li></ul></li></ul></li></ul><h3 id="屏蔽中断源的方式"><a href="#屏蔽中断源的方式" class="headerlink" title="屏蔽中断源的方式"></a>屏蔽中断源的方式</h3><ul><li><p>普通屏蔽方式</p><p><strong>IMR</strong>屏蔽字决定禁止某位<strong>IRi</strong>所对应的中断:<strong>IMi&#x3D;1</strong> 禁止</p></li><li><p>特殊屏蔽方式</p><ul><li>假定正在处理<strong>IR6</strong>，先进入特殊屏蔽方式， 然后设置<strong>IM6&#x3D;1</strong></li><li>这时除<strong>IR6</strong>外的所有中断请求均能得到响应</li><li>只能用特殊中断结束命令结束中断</li></ul></li></ul><h3 id="中断触发方式"><a href="#中断触发方式" class="headerlink" title="中断触发方式"></a>中断触发方式</h3><ul><li><p>边沿触发</p><p><strong>IRi</strong>上升沿表示有中断请求，触发后可以一直保持高电平</p></li><li><p>电平触发</p><p>在第<strong>1</strong>个<strong>INTA#<strong>结束前，</strong>IRi</strong>必须保持高电平，得到响应之后，输入端必须及时撤出高电平</p></li></ul><h3 id="级联工作方式"><a href="#级联工作方式" class="headerlink" title="级联工作方式"></a>级联工作方式</h3><ul><li><strong>n</strong>片<strong>8259A</strong>可支持<strong>7n+1</strong>个中断源</li><li>只能有一片<strong>8259A</strong>为主片 ➡️ 最多64个中断源</li><li><strong>CAS0-CAS2</strong> 链接主从片</li><li>主<strong>SP#&#x2F;EN#</strong> 接高，从接低</li><li>从<strong>INT</strong>接主<strong>IRi</strong></li></ul><h2 id="编程（只考初始化"><a href="#编程（只考初始化" class="headerlink" title="编程（只考初始化"></a>编程（只考初始化</h2><ul><li>初始化命令字<strong>ICW</strong>: <ul><li><strong>ICW1~ICW4</strong></li><li>整个系统工作过程中保持不变</li></ul></li><li>操作命令字<strong>OCW</strong>: <ul><li><strong>OCW1~OCW3</strong></li><li>改变初始化的8259A中断控制方式</li><li>屏蔽某些中断</li><li>读出8259A状态信息</li><li>可在<strong>初始化之后</strong>的任何时刻写入 8259A，并可多次设置</li></ul></li></ul><h4 id="内部寄存器的寻址"><a href="#内部寄存器的寻址" class="headerlink" title="内部寄存器的寻址"></a>内部寄存器的寻址</h4><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//image-20221121225902346.png" alt="image-20221121225902346" style="zoom:33%;" /><ul><li>🌰：<ul><li>接口地址为<strong>20H</strong>和<strong>21H</strong> </li><li><strong>MOV DX</strong>，<strong>20H</strong> ;<strong>A0&#x3D;0</strong>，写<strong>ICW1</strong> 等</li><li><strong>MOV DX</strong>，<strong>21H</strong> ;<strong>A0&#x3D;1</strong>，写<strong>ICW2</strong>，<strong>OCW1</strong> 等</li><li>记得<strong>OUT</strong></li></ul></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li><p>顺序</p><p>写 <strong>ICW1</strong> ➡️ 写 <strong>ICW2</strong> ➡️ （级连写<strong>ICW3</strong>）➡️ （写<strong>ICW4</strong>）</p></li><li><p><strong>ICW1（初始化字: 触发方式、级连控制、ICW4控制）</strong></p><table><thead><tr><th>A0</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3(触发方式)</th><th>D2</th><th>D1(级连控制)</th><th>D0(<strong>ICW4</strong>控制)</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>X</td><td>1</td><td>LTIM(<strong>1</strong> 高电平触发)</td><td>X</td><td>SNGL(<strong>1</strong> 单片)</td><td>IC4(<strong>1</strong> 要写<strong>ICW4</strong>)</td></tr></tbody></table><ul><li>写<strong>ICW1</strong>意味着重新初始化<strong>8259A</strong></li><li>写入<strong>ICW1</strong>后，<strong>8259A</strong>状态:<ul><li><strong>ISR</strong>和<strong>IMR</strong>全0</li><li>中断屏蔽方式：一般屏蔽方式</li><li>中断结束方式：非自动</li><li>状态读出逻辑预置为读<strong>IRR</strong></li></ul></li><li>记：<ul><li>上升沿触发+单片+不写ICW4  <strong>ICW1&#x3D;12H</strong></li></ul></li></ul></li><li><p><strong>ICW2（中断向量码）</strong></p><table><thead><tr><th>A0</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td>T7</td><td>T6</td><td>T5</td><td>T4</td><td>T3</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><ul><li><strong>T7~T3</strong>: 中断向量码的高<strong>5</strong>位</li><li><strong>T2~T0</strong>: 中断源的序号,自动填入</li><li><strong>例</strong> 若<strong>ICW2</strong>命令字为<strong>48H</strong>，则<strong>IR0</strong>的中断向量码为 <strong>48H</strong>，<strong>IR7</strong>的中断向量码为<strong>4FH</strong></li><li>记：<ul><li><strong>IR0</strong> 中断向量码 &#x3D; <strong>ICW2</strong></li></ul></li></ul></li><li><p><strong>ICW3（级连控制字）</strong></p><ul><li><p>主片</p><table><thead><tr><th>A0</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td>S7</td><td>S6</td><td>S5</td><td>S4</td><td>S3</td><td>S2</td><td>S1</td><td>S0</td></tr></tbody></table><ul><li><strong>Si&#x3D;1</strong> 对应<strong>IRi</strong>线上连接了从片</li></ul></li><li><p>从片</p><table><thead><tr><th>A0</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>ID2</td><td>ID1</td><td>ID0</td></tr></tbody></table><ul><li><strong>ID2</strong><del><strong>ID0</strong> 说明连接到主片的哪个<strong>IR</strong>引脚上；<strong>000～111</strong>分别对应**IR0</del>IR7**</li></ul></li></ul></li><li><p><strong>ICW4（中断结束方式字）</strong></p><table><thead><tr><th>A0</th><th>D7</th><th>D6</th><th>D5</th><th>D4(SFNM)</th><th>D3(BUF)</th><th>D2(M&#x2F;S)</th><th>D1(AEOI)</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>0</td><td><strong>1</strong> 特殊全嵌套方式<br /><strong>0</strong> 一般全嵌套方式</td><td></td><td></td><td><strong>1</strong> 自动<strong>EOI</strong>方式<br /><strong>0</strong> 非自动<strong>EOI</strong>方式</td><td>1</td></tr></tbody></table><table><thead><tr><th align="center">BUF</th><th align="center">M&#x2F;S</th><th align="center"></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">缓冲方式**&#x2F;<strong>主</strong>PIC**</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">缓冲方式**&#x2F;<strong>从</strong>PIC**</td></tr><tr><td align="center">0</td><td align="center">X</td><td align="center">非缓冲方式**&#x2F;**正常</td></tr></tbody></table></li></ul><h4 id="操作命令字"><a href="#操作命令字" class="headerlink" title="操作命令字"></a>操作命令字</h4><ul><li><p>写入顺序任意</p></li><li><p><strong>OCW1</strong>必须写入奇地址端口**(A0&#x3D;1)**</p></li><li><p><strong>OCW2、OCW3</strong>必须写入偶地址端口**(A0&#x3D;0)**</p></li><li><p><strong>OCW1（中断屏蔽字）</strong></p><table><thead><tr><th>A0</th><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td>M7</td><td>M6</td><td>M5</td><td>M4</td><td>M3</td><td>M2</td><td>M1</td><td>M0</td></tr></tbody></table><ul><li><strong>Mi&#x3D;1</strong> 中断请求线<strong>IRi</strong>被屏蔽</li><li>写入<strong>IMR</strong>寄存器</li><li>A0&#x3D;1时读OCW1可读出IMR</li></ul></li><li><p><strong>OCW2（中断结束和优先级循环）</strong></p><table><thead><tr><th>A0</th><th>D7(R)</th><th>D6(SL)</th><th>D5(EOI)</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>0</td><td>&#x3D;1 优先级自动循环</td><td>&#x3D; 1 <strong>SEOI</strong></td><td>&#x3D; 0 AEOI</td><td>0</td><td>0</td><td>L2</td><td>L1</td><td>L0</td></tr></tbody></table><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//image-20221121233826894.png" alt="image-20221121233826894" style="zoom:25%;" /></li><li><p><strong>OCW3（屏蔽方式和读出控制字）</strong></p><table><thead><tr><th>A0</th><th>D7</th><th>D6(ESMM)</th><th>D5(SMM)</th><th>D4(RIS)</th><th>D3</th><th>D2</th><th>D1(P)</th><th>D0(RR)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>&#x3D; 1 <br />允许特殊屏蔽方式</td><td>&#x3D; 1<br />特殊屏蔽方式置位</td><td>ISR&#x2F;IRR选择<br />(&#x3D;1读ISR)</td><td>0</td><td>1</td><td>&#x3D;1 查询方式</td><td>&#x3D; 1允许读寄存器</td></tr></tbody></table></li></ul><h4 id="PC机中断程序设计"><a href="#PC机中断程序设计" class="headerlink" title="PC机中断程序设计"></a><strong>PC</strong>机中断程序设计</h4><ul><li>主程序<ul><li>保存原中断向量</li><li>设置自己的中断向量</li><li>初始化堆栈指针</li><li>设置<strong>8259A</strong>的中断屏蔽字</li><li><strong>STI</strong></li></ul></li><li>中断服务程序<ul><li>保存所用到的寄存器内容</li><li>中断服务程序主体</li><li>恢复进入时保存的寄存器内容</li><li>发<strong>EOI</strong>命令</li><li><strong>STI</strong></li><li><strong>IRET</strong></li></ul></li></ul><h1 id="8255A-并行I-x2F-O接口芯片"><a href="#8255A-并行I-x2F-O接口芯片" class="headerlink" title="8255A 并行I&#x2F;O接口芯片"></a>8255A 并行I&#x2F;O接口芯片</h1><ul><li><p><strong>3</strong>个独立的<strong>8</strong>位并行I&#x2F;O</p><ul><li>端口<strong>A</strong> 常作数据端口，三种工作方式，A组</li><li>端口<strong>B</strong> 常作数据端口，两种工作方式，B组</li><li>端口<strong>C</strong> 可作数据、状态和控制端口，分两个<strong>4</strong>位，每位可独立操作（A组控制高4位、B组控低4位<ul><li>可以按位操作，当其工作于 方式<strong>0</strong>下且作为输出口时，作为输出的位需要设置初始状态(<strong>1or0</strong>)</li></ul></li></ul></li><li><p>分外设接口、内部逻辑、CPU接口三部分</p></li><li><p>内部寻址</p><table><thead><tr><th>端口A</th><th>端口B</th><th>端口C</th><th>控制寄存器</th></tr></thead><tbody><tr><td>00(A1A0)</td><td>01</td><td>10</td><td>11</td></tr></tbody></table></li><li><p>控制字</p><ul><li><p>方式选择控制字: 确定通道的工作方式，给出标识位 </p><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>D6~D3控制A组<ul><li>（D6D5）选择方式0～2</li><li>D4 &#x3D; 1 A组输入；D3 &#x3D; 1 C端口(上)输入</li></ul></li><li>D2～D0控制B组<ul><li>D2 选择方式0～1</li><li>D1 &#x3D; 1 B组输入</li><li>D0 &#x3D; 1 C端口(下)输入</li></ul></li></ul></li><li><p>通道<strong>C</strong>置位**&#x2F;<strong>复位控制字: 控制</strong>C**口的输出开关量</p><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>X</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>(D3D2D1)为C端口位选择，(000) ➡️ 0，(111) ➡️ 7</li><li>D0 &#x3D; 1 ➡️ 置位</li></ul></li><li><p>共用一根地址线，使用<strong>D7</strong>位判断控制字，<strong>D7</strong>&#x3D;<strong>1</strong>表示为方式选择控制字</p></li></ul></li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><h4 id="方式0-基本输入输出方式"><a href="#方式0-基本输入输出方式" class="headerlink" title="方式0:基本输入输出方式"></a>方式<strong>0</strong>:基本输入输出方式</h4><ul><li><p>适用于无条件传送和查询方式的接口电路</p><ul><li>查询输入输出方式: 把<strong>A</strong>、<strong>B</strong>口作为<strong>8</strong>位数据的输入&#x2F;输出口，<strong>C</strong>口的高**&#x2F;<strong>低</strong>4<strong>位分别定义为</strong>A<strong>、</strong>B**口的控制位和状态位</li></ul></li><li><p><strong>A</strong>口、<strong>C</strong>口的高<strong>4</strong>位、<strong>B</strong>口以及<strong>C</strong>口的低<strong>4</strong>位可分别定义为输入或输出，互相独立</p></li><li><p>输出的口有锁存能力，输入的口则无</p></li><li><p><strong>C</strong>口有按位置位&#x2F;复位能力</p></li></ul><h4 id="方式1-选通输入输出方式"><a href="#方式1-选通输入输出方式" class="headerlink" title="方式1:选通输入输出方式"></a>方式<strong>1</strong>:选通输入输出方式</h4><ul><li>适用于查询和中断方式的接口电路</li><li>一组选通控制信号控制<strong>A</strong>端口和<strong>B</strong>端口的数据输入输出，<strong>C</strong>位固定用作<strong>A</strong>、<strong>B</strong>口的选通控制信号<ul><li>A：<strong>PC3</strong>、<strong>PC6</strong>、<strong>PC7</strong>控制，B：<strong>PC2</strong>~<strong>PC0</strong>控制；指示两组数据口的状态及选通信号；</li><li><strong>PC4</strong>和<strong>PC5</strong>，用位控方式传送做I&#x2F;O</li><li>输入<ul><li><strong>STB#——</strong>选通信号，将外设数据送入<strong>8255</strong>的输入锁存器</li><li><strong>IBF——</strong>输入锁存器满。通知外设不能送下一个数据。 由<strong>STB</strong>的前沿产生。<strong>CPU</strong>用<strong>IN</strong>指令取走数据后， 信号被清除</li><li><strong>INTR——</strong>中断请求。<strong>STB#<strong>的后沿产生，用于中断 <strong>CPU</strong>，让</strong>CPU</strong>读走输入锁存器中的数据</li><li><strong>INTE——</strong>中断允许位，是否允许发出<strong>INTR</strong>请求。<strong>INTE &#x3D;1</strong>和<strong>IBF</strong>为高电平时，允许发出<strong>INTR</strong>请求</li></ul></li><li>输出<ul><li><strong>OBF#——</strong>通知外设取走数据</li><li><strong>ACK#——</strong>外设响应信号，表示已从数据端 口取走数据，使<strong>OBF</strong>变高</li><li><strong>INTR——ACK#<strong>上升沿产生，通知</strong>CPU</strong>输 出下一个数据(通常接到<strong>8259</strong>)。</li><li><strong>INTE——</strong>中断允许位，<strong>INTE&#x3D;1</strong>和<strong>OBF#<strong>为 高电平时，允许产生</strong>INTR</strong>信号。</li></ul></li></ul></li><li>数据端口均可设置为输入**&#x2F;**输出方式，均可锁存</li><li>中断控制<ul><li>中断允许触发器<strong>INTE</strong>控制，置位允许中断，复位禁止中断</li><li>选通输入<ul><li>端口<strong>A</strong>的<strong>INTEA</strong>对应<strong>PC4</strong> </li><li>端口<strong>B</strong>的<strong>INTEB</strong>对应<strong>PC2</strong></li></ul></li></ul></li></ul><h4 id="方式2-双向选通传送方式"><a href="#方式2-双向选通传送方式" class="headerlink" title="方式2:双向选通传送方式"></a>方式<strong>2</strong>:双向选通传送方式</h4><ul><li>用于 双向传送数据的外设和 查询和中断方式的接口电路</li><li>外设通过端口<strong>A</strong>即可向<strong>CPU</strong>发送数据，又能从<strong>CPU</strong>接收数据</li><li>只适用于端口<strong>A</strong>，端口<strong>B</strong>仍按方式<strong>0</strong>或方式<strong>1</strong> 工作</li><li>端口<strong>C</strong>的<strong>PC7</strong><del><strong>PC3</strong>位作为 端口<strong>A</strong>的控制**&#x2F;<strong>状态信号端口，</strong>PC2**</del><strong>PC0</strong>用于<strong>B</strong>组</li><li>端口<strong>A</strong>的输入**&#x2F;<strong>输出均有锁存功能；端口</strong>A**既可工作于查询方式，又可工作于中断方式</li></ul><h1 id="8253可编程计数器-x2F-定时器"><a href="#8253可编程计数器-x2F-定时器" class="headerlink" title="8253可编程计数器&#x2F;定时器"></a><strong>8253</strong>可编程计数器&#x2F;定时器</h1><h3 id="内部结构和工作原理"><a href="#内部结构和工作原理" class="headerlink" title="内部结构和工作原理"></a>内部结构和工作原理</h3><ul><li><p>计数器：设置好计数初值后，对外部触发脉冲响应减<strong>1</strong>计数，减为<strong>0</strong>时，输出结束信号</p></li><li><p>定时器：设置好定时常数后，对外部时钟信号响应减<strong>1</strong>计数，按定时常数不断产生时钟周期整数倍的定时间隔</p></li><li><p>内部总线连接 三个计数器、一个控制字寄存器、一个数据总线寄存器、一个I&#x2F;O读写</p></li></ul><h3 id="寄存器选择方式"><a href="#寄存器选择方式" class="headerlink" title="寄存器选择方式"></a>寄存器选择方式</h3><table><thead><tr><th>!CS</th><th>!RD</th><th>!WR</th><th>A1</th><th>A0</th></tr></thead><tbody><tr><td>0</td><td>0(读)</td><td>0(写)</td><td>选择寄存器</td><td>（A1A0） 11时设置控制字</td></tr></tbody></table><h3 id="外部引线"><a href="#外部引线" class="headerlink" title="外部引线"></a>外部引线</h3><ul><li>连接系统端<ul><li>D7~D0</li><li>片选</li><li>读写控制（两个</li><li>A1、A0</li></ul></li><li>计数通道<ul><li><strong>CLKn</strong> 时钟脉冲输入，计数器的计时基准</li><li><strong>GATEn</strong> 门控信号输入，控制计数器的启停</li><li><strong>OUTn</strong> 计数器输出信号，不同工作方式下产生不同波形(方波、电平或脉冲)</li></ul></li></ul><h3 id="内部计数器"><a href="#内部计数器" class="headerlink" title="内部计数器"></a>内部计数器</h3><p><strong>3</strong>个计数器相互独立，各自按不同的方式工 作，控制寄存器中的控制字决定其工作方式</p><p>每个计数器内部结构相同</p><ul><li><strong>1</strong>个<strong>8</strong>位控制寄存器（只写</li><li><strong>1</strong>个<strong>16</strong>位的计数初值寄存器</li><li><strong>1</strong>个<strong>16</strong>位计数寄存器（减法计数器，计数执行部件</li><li><strong>1</strong>个输出锁存器</li></ul><h3 id="控制字"><a href="#控制字" class="headerlink" title="控制字"></a>控制字</h3><p>8253必须先初始化才能正常工作，每个计数器都必须初始化一次</p><p>初始化<strong>8253</strong>时，<strong>CPU</strong>要向<strong>8253</strong>的控制字寄存器写入一个控制字规定<strong>8253</strong>的工作方式</p><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>(D7D6)(00~10)</td><td>计数器选择</td><td>(D5D4)(00~11)</td><td>读写控制</td><td>(D3D2D1)</td><td>(000~101)</td><td>工作方式选择</td><td>0(B计数) 1(D计数)</td></tr></tbody></table><table><thead><tr><th align="center">D5D4</th><th align="center">func</th></tr></thead><tbody><tr><td align="center">00</td><td align="center">计数器锁存(供<strong>CPU</strong>读)</td></tr><tr><td align="center">01</td><td align="center">只读**&#x2F;**写计数器低字节</td></tr><tr><td align="center">10</td><td align="center">只读**&#x2F;**写计数器高字节</td></tr><tr><td align="center">11</td><td align="center">读**&#x2F;<strong>写计数器</strong>16**位数<br />先低字节，后高字节</td></tr></tbody></table><h3 id="定时-x2F-计数工作过程"><a href="#定时-x2F-计数工作过程" class="headerlink" title="定时**&#x2F;**计数工作过程"></a>定时**&#x2F;**计数工作过程</h3><ol><li>设置<strong>8253</strong>的工作方式</li><li>设置计数初值到初值寄存器<ul><li><strong>初值</strong> &#x3D; 产生信号周期*<strong>8253</strong>时钟频率</li></ul></li><li>第一个<strong>CLK</strong>信号使初值寄存器的内容置入 计数寄存器，以后每来一个<strong>CLK</strong>信号，计数寄存器减<strong>1</strong></li><li>减到<strong>0</strong>时，<strong>OUT</strong>端输出一特殊波形的信号</li></ol><p>计数过程中还受到<strong>GATE</strong>信号的控制</p><h3 id="计数启动方式"><a href="#计数启动方式" class="headerlink" title="计数启动方式"></a>计数启动方式</h3><ul><li>程序指令启动（软件启动 <ul><li><strong>GATE</strong>端保持为高电平</li><li>写入计数初值后的第<strong>2</strong>个<strong>CLK</strong>脉冲的下降沿开始计数</li></ul></li><li>外部电路信号启动（硬件启动<ul><li><strong>GATE</strong>端有一个上升沿</li><li>对应<strong>CLK</strong>脉冲的下降沿开始计数</li><li>计数过程中若<strong>GATE</strong>出现上升沿，则重新装入原始计数值，重新开始计数</li></ul></li></ul><h3 id="计数过程中读计数值"><a href="#计数过程中读计数值" class="headerlink" title="计数过程中读计数值"></a>计数过程中读计数值</h3><ul><li>读取当前计数值（计数过程中）: <ul><li>先<strong>向控制寄存器写锁存命令</strong>(即<strong>D5D4&#x3D;00</strong>)，把当前计数值锁存到输出锁存器</li><li>再读相应端口数据</li></ul></li><li>停止计数器再读<ul><li>用<strong>GATE</strong>信号使计数器停止</li><li>规定<strong>RL1</strong>和 <strong>RL0</strong>的读写格式后读出</li></ul></li><li>读取装入的计数值: <ul><li>直接读取相应的端口</li><li>分两次读出: 先低字节，后高字节</li></ul></li></ul><h3 id="8253工作方式"><a href="#8253工作方式" class="headerlink" title="8253工作方式"></a><strong>8253</strong>工作方式</h3><p><strong>Tip：</strong></p><ol><li><strong>GATE</strong>出现上升沿时重新装填计数初值</li></ol><ul><li><p>方式 <strong>0</strong>（软启动）: <strong>计数结束产生中断</strong></p><ul><li>向计数器写完计数值时开始计数，<strong>OUT</strong>变为<strong>0</strong></li><li>计数到<strong>0</strong>时<strong>OUT</strong>输出为<strong>1</strong>，只计数一次</li><li><strong>GATE</strong>为低电平时停止计数</li><li>在计数时，若重新写入新的计数值，则按新的值重新工作</li></ul></li><li><p>方式 <strong>1</strong> （硬启动）: <strong>可重复触发的单稳态触发器</strong>（方式<strong>0</strong>的<strong>GATE</strong>受控循环</p><ul><li>设置方式后，<strong>OUT</strong>即变为高电平</li><li>写入计数值后，当<strong>GATE</strong>的上升沿时开始计数，<strong>OUT</strong>变为低；计数到<strong>0</strong>后， <strong>OUT</strong>变高</li><li>若计数中改变计数值，则要下个硬启动才会以新数计数</li></ul></li><li><p>方式<strong>2</strong>（软、硬启动）: <strong>分频器</strong>（方式<strong>1</strong>的自动版，可产生周期负脉冲</p><ul><li>为<strong>自动装入计数常</strong>数的计数器，计数期间<strong>OUT</strong>为<strong>1</strong>， 计数到<strong>1</strong>后输出<strong>1个周期(CLK)的0</strong>，并重新装入计数值计数</li><li>若计数中改变计数值，则要下个周期才会以新数计数（自然的，以周期自动装入常数</li></ul></li><li><p>方式 <strong>3</strong>（软、硬启动） : <strong>可编程方波发生器</strong>（更改了方式<strong>2</strong>的<strong>OUT</strong>占空比</p><ul><li><strong>OUT</strong>输出是一个占空比为<strong>1</strong>:<strong>1</strong>的方波 </li><li>若计数为奇数，则前面的<strong>1</strong>比后面的<strong>0</strong>多<strong>1</strong>个脉冲</li></ul></li><li><p>方式 <strong>4</strong> : <strong>软件触发的选通信号发生器</strong></p><ul><li>写入计数值后输出为高，开始计数（OUT）</li><li>计数结束时，输出<strong>1</strong>个脉冲低电平，再变高</li><li>若计数中改变计数值，则要结束后才会以新数计数</li></ul></li><li><p>方式 <strong>5</strong> : <strong>硬件触发的选通信号发生器</strong></p><ul><li><p>写入计数值后由<strong>GATE</strong>上升沿启动计数</p></li><li><p>其余与方式<strong>4</strong>相同</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="万恶的期末考" scheme="http://wonderland.plus/categories/%E4%B8%87%E6%81%B6%E7%9A%84%E6%9C%9F%E6%9C%AB%E8%80%83/"/>
    
    
    <category term="Code" scheme="http://wonderland.plus/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Shell随手记</title>
    <link href="http://wonderland.plus/posts/29962/"/>
    <id>http://wonderland.plus/posts/29962/</id>
    <published>2022-10-30T10:44:45.000Z</published>
    <updated>2022-11-18T14:47:50.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>‼️本随手记基于《Shell脚本学习指南》H.F. Beebe 学习</p><h2 id="Why-Shell"><a href="#Why-Shell" class="headerlink" title="Why Shell"></a>Why Shell</h2><p>简单、可移植、易开发</p><p>经过POSIX标准化</p><h2 id="简单脚本"><a href="#简单脚本" class="headerlink" title="简单脚本"></a>简单脚本</h2><p>显示系统有多少人登陆</p><p>| 管道符号表示前输出给后输入、Ctrl- D 表示 end-of-file、chmod赋予执行权限</p><p>第一行一般以 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh -</span> </span><br></pre></td></tr></table></figure><p>开头，以引用Shell，亦可引用其他解释器来执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; nusers</span>    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh -</span> </span><br><span class="line">who | wc -l</span><br><span class="line">^D</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x nusers</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./nusers执行测试</span></span><br></pre></td></tr></table></figure><p>即 command line 上测试 ➡️ 找到适当语法 ➡️ 放入单独脚本 ➡️ 赋予执行权限</p><h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>短线 - <ul><li>后面接一个字母</li><li>无参数选项可合并</li></ul></li><li>长选项<ul><li>两个短线 – 或一个均有</li></ul></li></ul><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>用 ; 分隔表示一次执行</li><li>用 &amp; 分隔表示并发执行</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>为某信息片段所起的名字</li><li>变量值常为空值 null</li><li>赋值语句等号两端不得空格，加引号包含空格</li><li>单行可多次赋值、可将数个变量的值赋给新变量，用引号包括</li><li>$ 表示取值</li></ul><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><h5 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h5><p>将参数打印，一般为提示用户作用</p><p>支持转译序列、 \c 表示忽略换行符</p><h5 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h5><p>模仿C中的 printf() 函数</p><h4 id="I-x2F-O重定向"><a href="#I-x2F-O重定向" class="headerlink" title="I&#x2F;O重定向"></a>I&#x2F;O重定向</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Code" scheme="http://wonderland.plus/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>ESP32随手记</title>
    <link href="http://wonderland.plus/posts/13657/"/>
    <id>http://wonderland.plus/posts/13657/</id>
    <published>2022-10-21T10:09:12.000Z</published>
    <updated>2022-11-18T14:47:50.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CoreData随手记</title>
    <link href="http://wonderland.plus/posts/42770/"/>
    <id>http://wonderland.plus/posts/42770/</id>
    <published>2022-10-20T05:00:13.000Z</published>
    <updated>2022-11-18T14:47:50.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Study" scheme="http://wonderland.plus/categories/Study/"/>
    
    
    <category term="iOS开发" scheme="http://wonderland.plus/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Blockchain随手记</title>
    <link href="http://wonderland.plus/posts/44436/"/>
    <id>http://wonderland.plus/posts/44436/</id>
    <published>2022-10-06T17:26:48.000Z</published>
    <updated>2022-10-07T04:01:54.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心idea"><a href="#核心idea" class="headerlink" title="核心idea"></a>核心idea</h1><p>通过后一个区块对前一个区块的引用，并以加密技术保证了区块链不可修改</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>分布式的，不可篡改的数据库，可验证、可信任。</p><h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><p>基于数学加密原理构建的不可伪造的货币系统，使用区块链技术实现了数字货币的可信支付</p><p><a href="https://bitcoin.org/bitcoin.pdf">第一篇paper&amp;比特币白皮书</a></p><p>比特币通过区块链技术，把整个账本全部公开，人手一份，全网相同，修改账本不会被其他人承认</p><p>无需中央信任机构，密码学理论保证货币防伪造</p><h2 id="区块链原理"><a href="#区块链原理" class="headerlink" title="区块链原理"></a>区块链原理</h2><p><strong>一个不断增长的全网总账本</strong></p><p>每个完全节点都拥有完整的区块链，节点总是信任最长的区块链，So，伪造区块链需要拥有超过51%的全网算力</p><p>区块链是由区块s构成的有序链表，每个区块都记录了一系列交易，并且，每个区块都指向前一个区块（通过记录上一个区块的哈希），从而形成一个链条，每个区块都有一个唯一的哈希标识。每一个区块还有一个Merkle哈希用来确保该区块的所有交易记录无法被篡改。</p><h2 id="P2P交易原理"><a href="#P2P交易原理" class="headerlink" title="P2P交易原理"></a>P2P交易原理</h2><p>无需信任中介参与的P2P（Peer-to-peer）交易</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>每个人都可以自己生成一个秘钥对，包含一个私钥和一个公钥：</p><blockquote><p>私钥被称为Secret Key或者Private Key，严格保密，不能泄漏给其他人</p></blockquote><blockquote><p>公钥被称为Public Key，可以公开给任何人</p></blockquote><p>私钥签签名，公钥用于他人验证</p><blockquote><p>常用的数字签名算法有：RSA算法，DSA算法和ECDSA算法。</p><p>比特币采用的签名算法是椭圆曲线签名算法：ECDSA，使用的椭圆曲线是一个已经定义好的标准曲线<strong>secp256k1</strong> </p><p>私钥本质上就是一个1～2256的随机数，公钥是由私钥根据ECDSA算法推算出来的，通过私钥可以很容易推算出公钥，所以不必保存公钥，但通过公钥无法反推私钥，只能暴力破解</p></blockquote><h3 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h3><p>比特币中，私钥本质上就是一个256位的随机整数</p><h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><p>支持智能合约的区块链平台</p><p>实现了一个图灵完备的脚本语言，运行在EVM（Ethereum Virtual Machine，以太坊虚拟机）中，任何人都可以编写合法的脚本来执行任意逻辑（有限制）</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>一种运行在区块链上的程序，保证在区块链网络的每一个节点中运行的结果完全相同。</p><p>为了消除程序运行的不确定性，智能合约有很多限制，例如，不支持浮点运算（因为浮点数有不同的表示方法，不同架构的CPU运行的浮点计算精度都不同），不支持随机数，不支持从外部读取输入等。</p><p>最常用的开发智能合约的语言是以太坊专门为其定制的<a href="https://docs.soliditylang.org/">Solidity</a>语言。</p><ul><li><p>智能合约部署在以太坊的区块链时，会根据部署者的地址和该地址的nonce分配一个合约地址，</p></li><li><p>合约地址和账户地址的格式没有区别，但<strong>合约地址没有私钥</strong>，没有人能直接操作该地址的合约数据。</p></li><li><p>要调用合约，唯一的方法是<strong>调用合约的公共函数</strong>  So 合约不能主动执行，只能被外部账户发起调用</p></li><li><p>合约内部也可以存储数据（存储在合约地址关联的存储上） So 合约具有状态，可实现比较复杂的逻辑</p></li><li><p>合约在执行的过程中，可以调用其他已部署的合约</p></li></ul><h3 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h3><p>大括号语言</p><p>静态类型，支持继承、库和复杂的用户定义类型等特性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Study" scheme="http://wonderland.plus/categories/Study/"/>
    
    
    <category term="Blockchain" scheme="http://wonderland.plus/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>VHDL随手记</title>
    <link href="http://wonderland.plus/posts/65250/"/>
    <id>http://wonderland.plus/posts/65250/</id>
    <published>2022-09-27T07:32:04.000Z</published>
    <updated>2022-11-18T14:41:43.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个完整的VHDL设计应该包括：</p><ul><li>实体（entity）。主要是用于描述和外部设备的接口信号以及类属等。</li><li>结构体（architecture）。用于描述系统的具体逻辑行为功能。</li><li>配置（configuration）。配置用来从库中选择所需单元爱组成系统设计的不同版本。</li><li>包集合（package）。包存放设计使用到的公共数据类型、常数和子程序等。</li><li>库（library）。库存放已经编译的实体、构造体、包集合和配置等。</li></ul><h1 id="实体-ENTITY"><a href="#实体-ENTITY" class="headerlink" title="实体 ENTITY"></a>实体 ENTITY</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="FPGA" scheme="http://wonderland.plus/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Principles of Communication by Matlab</title>
    <link href="http://wonderland.plus/posts/11189/"/>
    <id>http://wonderland.plus/posts/11189/</id>
    <published>2022-09-22T15:14:29.000Z</published>
    <updated>2022-10-07T03:25:19.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><h2 id="Lowpass-filter-signals"><a href="#Lowpass-filter-signals" class="headerlink" title="Lowpass-filter signals"></a>Lowpass-filter signals</h2><h5 id="Matlab提供函数lowpass"><a href="#Matlab提供函数lowpass" class="headerlink" title="Matlab提供函数lowpass"></a>Matlab提供函数<strong>lowpass</strong></h5><p>y &#x3D; lowpass(x,wpass)</p><p>y &#x3D; lowpass(x,fpass,fs)</p><p> y &#x3D; lowpass(xt,fpass) </p><p>y &#x3D; lowpass( ,Name,Value)</p><p>[y,d] &#x3D; lowpass()</p><p>lowpass()</p><h5 id="直接设计低通滤波器的参数"><a href="#直接设计低通滤波器的参数" class="headerlink" title="直接设计低通滤波器的参数"></a>直接设计低通滤波器的参数</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">N   = <span class="number">100</span>;        <span class="comment">% FIR filter order</span></span><br><span class="line">Fp  = <span class="number">20e3</span>;       <span class="comment">% 20 kHz passband-edge frequency</span></span><br><span class="line">Fs  = <span class="number">96e3</span>;       <span class="comment">% 96 kHz sampling frequency</span></span><br><span class="line">Rp  = <span class="number">0.00057565</span>; <span class="comment">% Corresponds to 0.01 dB peak-to-peak ripple</span></span><br><span class="line">Rst = <span class="number">1e-4</span>;       <span class="comment">% Corresponds to 80 dB stopband attenuation</span></span><br><span class="line"></span><br><span class="line">eqnum = firceqrip(N,Fp/(Fs/<span class="number">2</span>),[Rp Rst],<span class="string">&#x27;passedge&#x27;</span>); <span class="comment">% eqnum = vec of coeffs</span></span><br><span class="line">fvtool(eqnum,<span class="string">&#x27;Fs&#x27;</span>,Fs,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;White&#x27;</span>) <span class="comment">% Visualize filter</span></span><br></pre></td></tr></table></figure><p>N 表示transition region 的sharp程度，数字越大，越sharp；</p><p>Fp：通带截止频率</p><p>Fs：信号采样频率</p><p>Rp:  通带波纹ripple</p><p>Rst:  阻带衰减</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随手记" scheme="http://wonderland.plus/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
    <category term="Matlab" scheme="http://wonderland.plus/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>JavaNotes</title>
    <link href="http://wonderland.plus/posts/33992/"/>
    <id>http://wonderland.plus/posts/33992/</id>
    <published>2022-07-09T08:46:31.000Z</published>
    <updated>2022-10-07T03:25:19.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Coding Anywhere</title>
    <link href="http://wonderland.plus/posts/50883/"/>
    <id>http://wonderland.plus/posts/50883/</id>
    <published>2022-04-04T10:18:22.000Z</published>
    <updated>2022-04-06T16:01:20.660Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>到处编程的身影，挺有趣的，就记录一下</p><hr><h2 id="我都想不到，学的第一门编程语言是Octave🤣"><a href="#我都想不到，学的第一门编程语言是Octave🤣" class="headerlink" title="我都想不到，学的第一门编程语言是Octave🤣"></a>我都想不到，学的第一门编程语言是Octave🤣</h2><p>大一自习的时候，在写吴恩达机器学习课程的编程作业，从此coding成为了我大学生活的一部分</p><blockquote><p>Octave 免费版的Matlab，除了图形化界面拉垮，其他都可。但鉴于是免费开源的，已经很不错了</p></blockquote><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//octaveML.jpeg" alt="第一次写出线性回归hhh"></p><hr><h2 id="信号课的早八，而我在……"><a href="#信号课的早八，而我在……" class="headerlink" title="信号课的早八，而我在……"></a>信号课的早八，而我在……</h2><p>本来以为是在写微北洋，仔细一看是之前的 <strong>DDL Helper</strong> 哈哈，好像当时是有比赛比较急，否则我一般是听课的（开始大言不惭了hhh</p><p>从模糊的背景看得出是在讲取样函数时域的变换哈（或者是脉冲宽度&#x2F;周期 和 频谱的关系也有可能，看是第几章了</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//morning.jpeg" alt="DDL Helper!"></p><hr><h2 id="熬夜……这样的夜晚太多了"><a href="#熬夜……这样的夜晚太多了" class="headerlink" title="熬夜……这样的夜晚太多了"></a>熬夜……这样的夜晚太多了</h2><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//codenight.jpeg" alt="独自熬夜的夜晚"></p><hr><h2 id="高铁上也打过代码，然后晕车"><a href="#高铁上也打过代码，然后晕车" class="headerlink" title="高铁上也打过代码，然后晕车"></a>高铁上也打过代码，然后晕车</h2><p>晕车的症状一直持续到了回家的第二天 bbzl</p><p>再也不在车上看电脑了</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//traincode.jpeg" alt="高铁上的coding，晕了，没留下Mac的图hh"></p><hr><h2 id="在健身房累了……"><a href="#在健身房累了……" class="headerlink" title="在健身房累了……"></a>在健身房累了……</h2><p>还别有一番意境</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//code3.jpeg" alt="健身房的coding"></p><hr><h3 id="持续记录中📝……"><a href="#持续记录中📝……" class="headerlink" title="持续记录中📝……"></a>持续记录中📝……</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="生活" scheme="http://wonderland.plus/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Code" scheme="http://wonderland.plus/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>爱的诗</title>
    <link href="http://wonderland.plus/posts/26780/"/>
    <id>http://wonderland.plus/posts/26780/</id>
    <published>2022-04-04T10:13:44.000Z</published>
    <updated>2022-04-06T16:18:43.082Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一些古诗，<del>装一下</del> 文艺青年</p><hr><h2 id="正月十五夜"><a href="#正月十五夜" class="headerlink" title="正月十五夜"></a><strong>正月十五夜</strong></h2><p><strong>【唐代】苏味道</strong></p><p>火树银花合，星桥铁锁开。</p><p>暗尘随马去，明月逐人来。</p><p>游伎皆秾李，行歌尽落梅。</p><p>金吾不禁夜，玉漏莫相催。</p><blockquote><p>在唐代（至少是苏味道这个时代）我国一直施行 <strong>宵禁</strong> ，但唯独正月十五（加上十四、十六）这一天的夜晚允许百姓自由活动（铁锁开）。</p><p>火树银花这里特指上元节的灯景</p><p>星桥：天津三桥之一hhh</p><p>这一天会有俊男俊女走上街头丢手绢已示好感hhh</p></blockquote><h5 id="最爱：暗尘随马去，明月逐人来。"><a href="#最爱：暗尘随马去，明月逐人来。" class="headerlink" title="最爱：暗尘随马去，明月逐人来。"></a>最爱：暗尘随马去，明月逐人来。</h5><hr><h2 id="古意"><a href="#古意" class="headerlink" title="古意"></a>古意</h2><p><strong>【宋代】梅尧臣</strong></p><p>月缺不改光，剑折不改刚。</p><p>月缺魄易满，剑折铸复良。</p><p>势利压山岳，难屈志士肠。</p><p>男儿自有守，可杀不可苟。</p><blockquote><p>这是作者在范仲淹被贬到饶州的后一年所写的。那是北宋的一场权力斗争，还有欧阳修等多人一同被贬。</p><p>梅尧臣得知消息后，写了《彼型吟》《猛虎行》《古意》等，公开站在范仲淹一边。</p><p>话说为啥喜欢这首诗呢，前两句一直很喜欢  PS：高数月考两次72分的我竟敢辅修数学🥰</p></blockquote><h5 id="最爱：月缺不改光，剑折不改刚。"><a href="#最爱：月缺不改光，剑折不改刚。" class="headerlink" title="最爱：月缺不改光，剑折不改刚。"></a>最爱：月缺不改光，剑折不改刚。</h5><hr><h2 id="结客少年场行"><a href="#结客少年场行" class="headerlink" title="结客少年场行"></a><strong>结客少年场行</strong></h2><p><strong>【唐代】虞世南</strong></p><p>韩魏多奇节，倜傥遗声利。</p><p>共矜然诺心，各负纵横志。</p><p>结交一言重，相期千里至。</p><p>绿沉明月弦，金络浮云辔。</p><p>吹箫入吴市，击筑游燕肆。</p><p>寻源博望侯，结客远相求。</p><p>少年怀一顾，长驱背陇头。</p><p>焰焰戈霜动，耿耿剑虹浮。</p><p>天山冬夏雪，交河南北流。</p><p>云起龙沙暗，木落雁门秋。</p><p>轻生殉知己，非是为身谋。</p><blockquote><p>本诗是写游侠题材的乐府旧题；“少年场”，即是少年聚集之地</p><p>从首句开始，以下便围绕“多奇节”而展开。此“奇”非他“奇”，而是奇在其轻身重义上，奇在其士为知己者死上，奇在其“遗声利”“非是为身谋”上。</p><p>借此祝愿“各负纵横志”的我们都能如愿以偿。</p></blockquote><h5 id="最爱：共矜然诺心，各负纵横志。"><a href="#最爱：共矜然诺心，各负纵横志。" class="headerlink" title="最爱：共矜然诺心，各负纵横志。"></a>最爱：共矜然诺心，各负纵横志。</h5><hr><h4 id="持续更新中……"><a href="#持续更新中……" class="headerlink" title="持续更新中……"></a>持续更新中……</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="诗词" scheme="http://wonderland.plus/categories/%E8%AF%97%E8%AF%8D/"/>
    
    
    <category term="文艺青年" scheme="http://wonderland.plus/tags/%E6%96%87%E8%89%BA%E9%9D%92%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>《A Mathematical Theory of Communication》译文及解读</title>
    <link href="http://wonderland.plus/posts/39005/"/>
    <id>http://wonderland.plus/posts/39005/</id>
    <published>2022-04-03T02:51:51.000Z</published>
    <updated>2022-04-06T01:54:57.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>祖师爷的开山之作，这篇论文标志着信息论的诞生，也将人类社会拉入了信息时代</p><p>PS：这也是我昵称的由来 A.S. 即 After Shannon （一些科幻小说以此记年</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//ShannonWheel.JPG" alt="杂耍和独轮车是祖师爷的一大爱好"></p><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>近年来，各种调制方法如 PCM 和 PPM 通过增加带宽换取更低的信噪比，增加了人们对通信一般理论的兴趣。奈奎斯特[^1] 和哈特利[^2] 关于这一问题的重要论文中包含了这种理论的基础。在本文中，我们将扩展该理论，增加许多新的因素，尤其是信道中噪声的影响，以及在原始消息的统计结构和信息最终目的地的性质（不变）而可能的节省（带宽？）。</p><blockquote><p>PCM: <strong>Pulse-code modulation</strong>  即 脉冲编码调制，一种将模拟信号数字化的方法，详见<a href="https://en.wikipedia.org/wiki/Pulse-code_modulation">PCM</a></p></blockquote><blockquote><p>PPM: <strong>Pulse-position modulation</strong> 即 脉冲位置调制，一种调制信号的方法，详见<a href="https://zh.wikipedia.org/wiki/%E8%84%89%E5%86%B2%E4%BD%8D%E7%BD%AE%E8%B0%83%E5%88%B6">PPM</a></p></blockquote><p>通信的基本问题是在一个地方上准确或近似地再现在另一个地方上选择（发送）的消息。这些信息往往有<strong>意义</strong>；也就是说，它们指代或依据 具有某些物理或概念实体的系统，<strong>通信的语义方面与工程问题无关</strong>。重要的是，实际信息是从一组可能的信息中<strong>选择</strong>的。系统的设计必须使每个可能的选择都可以运行，而不仅仅是实际的选择，因为在设计系统时选择是未知的。</p><p>如果集合中的消息数量是有限的，且所有选择的概率都是相同的，那么一个数字或是一个数字的任何单调函数可以被视为从集合中选择一条消息时所产生的信息的度量。正如哈特利所指出的，最自然的选择是<strong>对数函数</strong>。但是当我们考虑消息的统计信息，并且有一个连续的消息范围时，这个定义必须被极大地推广，我们将在所有的情况下使用同一个基本的对数度量。</p><p>由于以下各种原因，对数度量更方便：</p><ol><li>它实际上更有用。工程中重要的参数，如时间、带宽、继电器数量等，往往随概率的对数线性变化。例如，将一个继电器添加到一个组（group，不知道是什么）中会使继电器的可能状态数翻倍。这个数字对<strong>以2为底的对数</strong>加1。时间翻倍大致等于可能的消息数的平方，或是其对数翻倍，等等。</li><li>它更接近于我们对正确度量的直觉。这与第一点密切相关，因为我们通过与通用标准的线性变化比较直观地衡量实体。例如，人们认为，两张穿孔卡片的信息存储容量应该是一张穿孔卡片的两倍，（两张穿孔卡片）传输信息的两个相同通道的容量应该是一张穿孔卡片的两倍。</li><li>这在数学上更合适。许多限制操作在对数方面很简单，但在概率方面需要复杂的描述。</li></ol><p>选择不同对数底数对应于不同的测量信息的单位。如果使用底数2，结果单位可能被称为二进制数字（binary digits），或是更简洁的 <strong>bits</strong>，一个由 J.W.Tukey（快速傅立叶变换发明人）建议的单词。具有两个稳定状态的设备，如继电器或触发器电路，可以存储一比特信息。N这样的设备可以存储N比特，因为可能状态的总数是 $2^N$，$log_22^N&#x3D;N$ 。如果使用底数10，则单位可以称为decimal digits。这样一dit就大致等于 $3\frac{1}3$bit。$$\begin{align*} log_2M &amp;&#x3D; log_{10}M&#x2F;log_{10}2 \\  &amp;&#x3D;3.32 log_{10}M \end{align*}$$    台式计算机上的数字轮有十个稳定的位置（显然现在的现代计算机不是这样的😂），因此具有一个十进制数字的存储容量。在涉及整合和差异化的分析工作中，基数 $e$ 有时是有用的。由此产生的信息单位将被称为自然单位（即奈特）。从基数 $a$ 到基数 $b$ 的变化只需要乘以 $log_ba$ 即可。</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//paper1.png" alt="图1"></p><p>我们所说的通信系统是指图1中示意性指示的系统。它基本上由五部分组成：</p><ol><li><p>信源，它产生一条消息或一系列消息，并传送给接收终端。信息可以有多种类型：</p><ul><li><p>电传系统电报中的字母序列</p></li><li><p>时间 $f(t)$ 的单一函数，如在无线电或电话中</p></li><li><p>时间和其他变量的函数，如在黑白电视中</p><blockquote><p>在这里，信息可以被认为是两个空间坐标和时间函数 $f(x) , f(y)$ 点 $(x,y)$ 的亮度和拾取管板上的时间 $t$</p></blockquote></li><li><p>两个或两个以上的时间函数，例如 $f(t),g(t),h(t)$  </p><blockquote><p>三维声音传输，或系统打算在多路传输中为多个单独的通道提供服务，则也为这种情况</p></blockquote></li><li><p>几个变量的函数</p><blockquote><p>在彩色电视中，信息由三个定义在一个三维连续体中的函数 $f(x,y,t),g(x,y,t),h(x,y,t)$ 组成，我们也可以将这三个函数视为该区域定义的向量场的组成部分，类似地，几个黑白电视源将产生由多个三变量函数组成的“信息”</p></blockquote></li><li><p>以上的各种组合也会出现</p><blockquote><p>例如在具有相关音频频道的电视中。</p></blockquote></li></ul></li><li><p>以某种方式对信息进行操作以产生适合通过信道传输的信号的发射器。在电话技术中，这种操作仅仅是将声压转换成与之成比例的电流。在电报中，我们有一种编码操作，它在信道上产生一系列与信息对应的点、破折号和空格（摩尔斯）。在多路PCM系统中，必须对不同的语音功能进行采样、压缩、量化和编码，并最终进行适当的插值以构造信号。声码器系统（？）、电视和频率调制是应用于消息以获得信号的复杂操作的其他示例。</p></li><li><p>信道仅仅是用来将信号从发射机传输到接收机的媒介。它可能是一对电线、一根同轴电缆、一段无线电频率、一束光束等等（祖师爷的神预言啊，光纤的坑这时候就挖了吗？）</p></li><li><p>接收机通常执行与发射机相反的操作，从信号中重构信息</p></li><li><p>目的地是消息要传达给的人（或物）</p></li></ol><p>我们希望考虑一些涉及通信系统的一般问题。要做到这一点，首先需要将涉及的各种元素表示为数学实体，并对物理实体进行适当的理想化。我们可以大致将通信系统分为三大类：离散、连续和混合。我们所说的<strong>离散系统是指信息和信号都是离散符号序列的系统</strong>。一个典型的例子是电报，其中信息是字母序列，信号是点、破折号和空格序列。<strong>连续系统是指信息和信号都被视为连续的系统</strong>，例如收音机或电视。混合系统是同时出现离散变量和连续变量的系统，例如语音的PCM传输。<br>我们首先考虑离散情形。这件事不仅在通信理论中有应用，而且在计算机理论、电话交换机设计和其他领域也有应用。此外，离散的情况是连续和混合情况的基础，后两者将在论文的后半部分讨论。</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//Shannon.jpeg" alt="香农的肖像照，此摄影师拍摄过许多伟大的人物"></p><h1 id="PART-I-DISCRETE-NOISELESS-SYSTEMS"><a href="#PART-I-DISCRETE-NOISELESS-SYSTEMS" class="headerlink" title="PART I: DISCRETE NOISELESS SYSTEMS"></a>PART I: DISCRETE NOISELESS SYSTEMS</h1><h2 id="1-THE-DISCRETE-NOISELESS-CHANNEL"><a href="#1-THE-DISCRETE-NOISELESS-CHANNEL" class="headerlink" title="1. THE DISCRETE NOISELESS CHANNEL"></a>1. THE DISCRETE NOISELESS CHANNEL</h2><p>电传打字和电报是离散信道传输信息的两个简单例子。通常离散信道指的是能够使一组有限的基本符号 $S_1,\ldots ,S_n$ 中的<strong>一系列选择</strong>可以从一个点传输到另一个点的系统。假设每个符号 $S_i$ 持续时间为 $t_i$ 秒（对于不同 $S_i$不必相同 ，例如电报中的点和破折号）。不要求 $S_i$ 的所有可能序列能够在系统上传输而仅允许某些序列。这些（序列）将是通道传输的可能信号。因此，在电报中，假设符号是：</p><ol><li>一个点，由一个单位时间的闭合线路和一个单位时间的开放线路组成（即开关闭合与打开时间比为1:1，下同）</li><li>短划，由三个单位时间的闭合和一个单位时间的打开组成</li><li>一个字母间隔，由三个单位时间的打开组成</li><li>一个单词间隔，由六个单位时间的打开组成</li></ol><p>我们可能会对允许的序列设置条件，比如不能有空格相互跟随（因为如果两个字母空格相邻，那么它与单词空格相同）。我们现在考虑的问题是应该如何测量这样一个信道传输信息的能力。</p><p>在电传打字机的情况下，所有符号的持续时间相同，并且允许 $32$ 个符号的任何排序序列，这使得答案很简单。每个符号代表五比特信息。如果系统每秒传输 $n$ 个符号，那么很自然地说信道容量为每秒 $5n$ 比特。这并不意味着电传打字机信道将始终以该速率传输信息——这只是可能的最大速率，实际速率是否达到该最大值取决于为信道提供信息的信源，稍后将对此讨论。</p><p>在更一般的情况下，对于不同长度的符号和允许序列的约束，我们做出以下定义：</p><div class="note info modern"><p>定义：离散信道的容量C由下式给出：$$C &#x3D; \displaystyle\lim_{x \rightarrow 0}\frac{logN(T)}{T}$$ 其中 $N(T)$ 代表 $T$ 时间内允许通过的信号数量 </p></div><p>很容易看出，在电传打字机的情况下，就等于之前的结果。可以证明，在大多数我们关心的情况下，这个极限总是存在的，并且是一个有限数。假设所有符号序列$S_1,\ldots ,S_n$都是允许的，并且这些符号的持续时间为 $t_1,\ldots , t_n$ 。那么信道容量是多少？如果使用 $N(t)$ 表示持续时间 $t$ 内的序列数，我们得到 $$N(t) &#x3D; N(t-t_1) + N(t-t_2) + , \ldots , + N(t-t_n).$$</p><p>总数等于以$S_1,\ldots ,S_n$结尾的序列数之和即分别是 $N(t-t_1), N(t-t_2)  , \ldots , N(t-t_n)$ ，根据一个众所周知的有限差分的结论，当 $t$ 很大时，$N(t)$ 是 $X_0^t$ 的近似解，其中 $X_0$ 是以下特征方程的最大实解：$$X^{-t_1} + X^{-t_2} + \ldots + X^{-t_n}$$</p><p>因此有：$$C &#x3D; logX_0.$$</p><p>如果允许的序列受到限制，我们仍然可以从特征方程中获得这种类型的差分方程并找到 $C$。如上述电报例子中提到的（约束）$$N(t) &#x3D; N(t-2) + N(t-4) + N(t-5)+N(t-7)+N(t-8)+ N(t-10).$$</p><blockquote><p>PS: 其中 2、4、5、7、8、10 为之前讨论的四种情况的可能组合。</p></blockquote><p>正如我们所看到的，根据最后一个或下一个出现的符号来计算符号序列。这样 $C$ 就是 $-log\mu_0$ ，其中 $\mu_0$ 是 $1 &#x3D; \mu^2 + \mu^4 + \mu^5 + \mu^7 + \mu^8 + \mu^{10}$ 的正数根。这样我们就可以算出 $C&#x3D;0.539$ 。</p><p>[^1]:  Nyquist, H., “Certain Factors Affecting Telegraph Speed,” Bell System Technical Journal, April 1924, p. 324; “Certain Topics in Telegraph Transmission Theory,” A.I.E.E. Trans., v. 47, April 1928, p. 617. ↩<br>[^2]: Hartley, R. V. L., “Transmission of Information,” Bell System Technical Journal, July 1928, p. 535.</p><hr><p>毕竟是55页的paper，分若干次更新吧hh</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="通信相关" scheme="http://wonderland.plus/categories/%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="改变世界的Paper们" scheme="http://wonderland.plus/tags/%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%E7%9A%84Paper%E4%BB%AC/"/>
    
  </entry>
  
  <entry>
    <title>嘿，Siri</title>
    <link href="http://wonderland.plus/posts/36772/"/>
    <id>http://wonderland.plus/posts/36772/</id>
    <published>2022-04-01T16:08:17.000Z</published>
    <updated>2022-04-03T16:53:43.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Siri-和-SiriKit是啥"><a href="#Siri-和-SiriKit是啥" class="headerlink" title="Siri 和 SiriKit是啥"></a>Siri 和 SiriKit是啥</h2><p>是一款内置在苹果 iOS 系统中的人工智能助理软件，“Siri” 一词在挪威语中的意思是“带领你走向胜利的美丽女神”</p><p>SiriKit 允许通过 Siri 界面并通过语音命令访问应用程序功能。</p><h2 id="SiriKit-能干啥"><a href="#SiriKit-能干啥" class="headerlink" title="SiriKit 能干啥"></a>SiriKit 能干啥</h2><ul><li>信息传递</li><li>支付相关</li><li>控制媒体</li><li>车载助手</li><li>等</li></ul><p>尽管早在 iPhone 4S 时 Siri 就是 iOS 的一部分，但直到 iOS 10 的推出，Siri 的一些功能才通过 SiriKit 提供给开发者。</p><p>SiriKit 的目的是允许 Siri 通过语音命令访问 App 的一些功能。</p><p>例如，课表管理App可以允许用户通过语音询问下一节课是什么。</p><h2 id="Siri-和-SiriKit"><a href="#Siri-和-SiriKit" class="headerlink" title="Siri 和 SiriKit"></a>Siri 和 SiriKit</h2><p>当 App 与 SiriKit 集成时，Siri 会处理：</p><ul><li>与用户交流</li><li>解释用户话语的含义</li><li>处理上下文相关的所有任务</li></ul><p>然后 Siri 将用户的请求打包成一个 <em>Intents</em>  并将其传递给 App。App负责验证是否提供了足够的信息来执行任务，并指示 Siri 请求任何缺失的信息。</p><p>一旦 <em>Intents</em>  包含所有必要的数据，App 就会执行请求的任务并将结果通知 Siri。这些结果将由 Siri 或 App 呈现。</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com//SiriMessageLink.png" alt="Siri的信息传递"></p><h2 id="SiriKit-Intents"><a href="#SiriKit-Intents" class="headerlink" title="SiriKit  Intents"></a>SiriKit  Intents</h2><p>每个域都允许用户请求一组预定义的任务或意图，以由应用程序完成。意图表示 Siri 知道的特定任务，并且 SiriKit 期望集成的 iOS 应用程序能够执行该任务。</p><p>例如，消息域包括发送和搜索消息的意图，而锻炼域包含选择、开始和结束锻炼的意图。当用户通过 Siri 向某个应用发出请求时，该请求会被放入相应类型的 Intent 对象中，并传递给该应用进行处理。</p><h2 id="SiriKit-Integration-工作原理"><a href="#SiriKit-Integration-工作原理" class="headerlink" title="SiriKit Integration 工作原理"></a>SiriKit Integration 工作原理</h2><p>Siri integration 扩展作为 Target 添加到 Xcode 中的应用程序项目中。</p><p>SiriKit 提供了两种类型的扩展，其中关键的一种是 Intents 扩展。此扩展包含一个 <em>意图处理程序</em> ，它是 Intents 框架的 INExtension 类的子类，并包含 Siri 在与用户通信过程中调用的方法。</p><p>意图处理程序的职责是验证 Siri 是否已从用户那里收集到所有必需的信息，然后执行意图中定义的任务。</p><p>当用户通过 Siri 向应用发出请求时，第一个调用的方法是 Intents Extension 中包含的意图处理程序类的*handler(forIntent:)*方法。此方法传递当前意图对象并返回 将用作意图处理程序的 对象的 引用。这可以是意图处理程序类本身，也可以是已配置的为实现一个或多个意图处理协议的另一个类。</p><p>Siri 调用处理程序方法后的第一步工作会调用一系列方法来解析与意图关联的参数。</p><h2 id="解析意图参数"><a href="#解析意图参数" class="headerlink" title="解析意图参数"></a>解析意图参数</h2><p>每个意图类型都与一组参数相关联，这些参数用于提供有关应用程序要执行的任务的详细信息，其中有些是可选的: </p><blockquote><p>发送消息的意图必须包含有效的接收者参数才能发送消息。</p><p>另一方面，照片搜索意图的许多参数是可选的:</p><blockquote><p>用户可能想要搜索包含特定人物的照片，而不管照片的拍摄日期如何。</p></blockquote></blockquote><p>Siri 知道每种意图类型的所有可能参数。Siri 将要求应用程序扩展的意图处理程序通过相应的方法来 <em><strong>解析参数</strong>。</em></p><ul><li><p>如果 Siri 已经有一个参数，它将要求意图处理程序验证该参数是否有效。</p></li><li><p>如果 Siri 还没有参数的值，它将询问意图处理程序是否需要该参数。</p></li><li><p>如果意图处理程序通知 Siri 该参数不是必需的，则 Siri 不会要求用户提供它。</p></li><li><p>另一方面，如果需要该参数，Siri 会要求用户提供信息。</p></li></ul><p>一旦参数被解析或指示为不需要，Siri 将调用意图处理程序的<em><strong>确认方法</strong></em>（confirm。</p><h2 id="确认方法"><a href="#确认方法" class="headerlink" title="确认方法"></a>确认方法</h2><p>confirm 方法在扩展意图处理程序中实现，并在所有意图参数都已解析后由 Siri 调用。如果confirm 方法报告就绪状态，Siri 会调用<em><strong>处理方法</strong></em>（handle。</p><h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>处理方法 是执行与意图相关的活动的地方。任务完成后，会将响应传递给 Siri。响应的形式将取决于所执行活动的类型。</p><blockquote><p>照片搜索活动将返回匹配照片的数量，而发送消息活动将指示消息是否发送成功。</p></blockquote><p>handle 方法也可能返回<em>continueInApp</em>响应。这告诉 Siri 任务的其余部分将在主应用程序中执行。收到此响应后，Siri 将启动 App，并传入一个 NSUserActivity 对象。</p><blockquote><p>NSUserActivity 是一个可以保存和恢复应用程序状态的类。</p></blockquote><p>在 iOS 10 及更高版本中，NSUserActivity 类有一个额外的属性，允许 NSInteraction 对象与应用程序状态一起存储。Siri 使用这种属性来存储会话的 NSInteraction 对象并将其传递给主 iOS 应用程序。</p><p>例如，照片搜索意图需要使用<em>continueInApp</em>响应和用户活动对象，以便可以将搜索期间找到的照片呈现给用户（SiriKit 目前不提供一种机制来显示来自照片搜索意图的图像Siri 用户界面）。</p><p>一个意图处理程序类可能包含多个 handle 方法来处理不同的意图类型。</p><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><ol><li><p>+ Capability Siri （需要开发者账户</p></li><li><p><em>Info.plist</em>     <em>Privacy – Siri Usage Description</em> </p></li><li><p>调用 INPreferences 类的*requestSiriAuthorization()*类方法 应该在应用程序第一次运行时进行此调用，不仅可以获取授权，还可以让用户了解应用程序包含 Siri 支持  <em>scenePhase</em>   <em>onChange()</em> </p></li><li><p>将 Intents 扩展添加到准备开始 SiriKit 集成的项目中将 Intents 扩展添加到准备开始 SiriKit 集成的项目中</p><p><em>Target…</em>Intents Extension</p></li></ol><p>未待完续…………</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="iOS开发" scheme="http://wonderland.plus/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="SiriKit" scheme="http://wonderland.plus/tags/SiriKit/"/>
    
  </entry>
  
  <entry>
    <title>一笔画的背后</title>
    <link href="http://wonderland.plus/posts/40687/"/>
    <id>http://wonderland.plus/posts/40687/</id>
    <published>2022-03-31T15:00:03.000Z</published>
    <updated>2022-04-10T04:11:56.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天排队论的老师讲起了图论hhh</p><p>让我想起了小时候看的有关一笔画的东西，能不能一笔画成的规律倒是知道，但竟一直没想过如何证明证明。</p><p>今天正好借着图论开课的机会重新想一想，然后就翻到了欧拉的证明，大道至简，清晰的思维值得记录。</p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p><strong>一笔画问题（Eulerian graph）</strong>是图论中一个著名的问题。一笔画问题起源于柯尼斯堡七桥问题。数学家欧拉在他1736年发表的论文《柯尼斯堡的七桥》中不仅解决了七桥问题，也提出了<strong>一笔画定理</strong>，解决了一笔画问题。</p><p>欧拉的研究是图论的开端。</p><p>莱布尼茨在1670年写给惠更斯的一封信中写道：</p><blockquote><p>我不满足于代数，因为它既不能给出最短的证明，也不能给出最漂亮的几何结构。因此，考虑到这一点，我认为我们还需要另一种分析，几何的或线性的，直接处理位置，就像代数处理数值那样。</p></blockquote><p>莱布尼茨的研究如今被称为 <strong>拓扑学</strong>，但作为一个数学领域在当时发展缓慢。正如高斯在1833年指出的</p><blockquote><p>莱布尼茨开创了位置几何学，但当时只有欧拉和范德蒙（对，就是范德蒙行列式那位）两位几何学家对其略知一二。一个半世纪后，我们才懂得并掌握了这一几何学。</p></blockquote><p>就是在高斯口中对几何学 <em>略知一二</em> 的欧拉的一篇论文，被誉为是西方现代图论的起点。</p><p>在数学界，18世纪被誉为是欧拉的时代。令人惊讶的是，欧拉的近900本书、论文和其他作品中，有近一半是在1771年几乎完全失明后写的。（天才况且如此……</p><p><img src="https://blogimgs-1310551706.cos.ap-beijing.myqcloud.com/euler.jpg" alt="欧拉"></p><p>在1736年的 <em>Commentarii Academiae Scientiarum Imperialis Petropolitanae</em> 上，欧拉对现在著名的柯尼斯堡桥问题进行了数学描述：有没有可能计划在柯尼斯堡镇漫步一次，但是这座镇上的七座桥每座桥只能穿过一次？</p><blockquote><p>The problem, which I am told is widely known, is as follows: in K¨onigsberg in Prussia, there is an island A, called the Kneiphof ; the river which surrounds it is divided into two branches, as can be seen in Fig. [1.2], and these branches are crossed by seven bridges, a, b , c , d , e , f and g. Concerning these bridges, it was asked whether anyone could arrange a route in such a way that he would cross each bridge once and only once. I was told that some people asserted that this was impossible, while others were in doubt: but nobody would actually assert that it could be done. From this, I have formulated the general problem: whatever be the arrangement and division of the river into branches, and however many bridges there be, can one ﬁnd out whether or not it is possible to cross each bridge exactly once?</p></blockquote><p><img src="/../images/%E4%B8%80%E7%AC%94%E7%94%BB%E7%9A%84%E8%83%8C%E5%90%8E/7bridge.png" alt="七桥图示"></p><p>像其他早期的图论工作一样，柯尼斯堡七桥问题看起来只不过是一个有趣的谜题。然而，从这种看似琐碎的起源，图论发展成为一种强大而深刻的数学理论，如今在物理、生物和社会科学中有着广泛的应用。</p><h2 id="证明它！"><a href="#证明它！" class="headerlink" title="证明它！"></a>证明它！</h2><h4 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h4><p>在开始证明之前，值得注意的是欧拉将城市复杂的画卷（见封图）抽象成了简单的草图，在现代图论中，我们进行了进一步的简化（仅保留点和连接点的线）。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>当然有一种大力出奇迹的方法可以证明这个问题，就是列出所有可能的情况，找不到符合题设的就OK了。但是这种方法有几点弊端：</p><ul><li>不适用于更复杂的情况（兄弟，真的遍历不完的</li><li>不能抽象为理论！！（这很重要，琐碎变为伟大的关键</li><li>会浪费注意力在那些根本不可能成为答案的路径上</li></ul><p>欧拉的整个方法依赖于一种特别方便的方式，用这种方式可以表示桥梁之间的关系。</p><h4 id="问题表示方法"><a href="#问题表示方法" class="headerlink" title="问题表示方法"></a>问题表示方法</h4><p>我们使用大写字母A、B、C、D表示河流分隔的每个陆地区域（见上图）。如果一个旅行者通过a桥或b桥从A到B，将其写为AB</p><blockquote><p>AB中第一个字母指的是旅行者离开的区域，第二个字母指的是他过桥后到达的区域。</p></blockquote><p>因此，如果旅客离开B，穿过f桥进入D，则该路径用BD表示，两个路径AB和BD的组合用三个字母ABD表示，其中中间字母B表示第一条路径结束的区域和第二条路径开始的区域。如果旅行者又穿过桥g从D到C，我将用四个字母ABDC来表示这三个连续的路径</p><blockquote><p>这四个字母ABDC意味着旅行者从A开始，穿过B，再到D，最后到达C。</p></blockquote><p>由于每个陆地区域都被一条河的支流隔开，若要走过A、B、C、D 四个地方，旅行者必须穿过三座桥。类似地，四座桥的连续跨越将由五个字母表示。所以一般来说，无论旅行者跨越多少座桥，他的旅程都可以由一个比桥的数量大一个的字母来表示。因此，<strong>跨越七座桥需要八个字母来代表它</strong>。</p><blockquote><p>欧拉的这种表示方法使得图表本身对于解决问题变得不再必要，在现代图论中，我们用集合$V &#x3D; {v_0, v_1, \ldots , v_n}$ 和集合 $E &#x3D; {e_0, e_1, \ldots , e_m}$ 来表示，其中集合$V$ 代表顶点的集合， $E$ 代表连接顶点的边的集合。</p></blockquote><p>如果有一条回路可以遍历所有的顶点而每一条边只走过一次，那这样的路就被称作欧拉路径（包含所有顶点的迹），也是本题设想要寻找的路径。</p><p>另有更严格的条件：欧拉回路（包含所有顶点的迹且首位相接）</p><h4 id="存在吗？"><a href="#存在吗？" class="headerlink" title="存在吗？"></a>存在吗？</h4><p>因此，问题归结为找到由四个字母A、B、C、D组成的八个字母序列，其中A、B、C、D又重复。在寻找这样一个序列之前，先弄清楚是否有可能以这种方式排列字母（即找到题设路径），因为如果可以<strong>证明没有这样的排列存在</strong>，那么任何查找排列的工作都是毫无意义的。</p><p>为了尝试这样的规则，我考虑了单个区域A，有a、b、c、d 四座桥与A关连。让我们先来看看通向A的单个桥：如果一个旅行者穿过这座桥，他必须在穿越前或者在穿越后到达A，因此在任何一种情况下，字母a都会在上述表示中出现一次。如果有三座桥（比如a、b和c）通向A，如果旅行者穿过这三座桥，那么在他的旅程中，无论他是否从a开始他的旅程，字母a都将出现两次。类似地，如果五座桥通向A，那么在通过所有桥的表示中，字母A会出现三次。</p><p>因此，在柯尼斯堡七桥的问题的路线表示中，因为五座桥（a、b、c、d、e）通向A区，所以字母A必须出现三次。接下来，由于三座桥通向b，字母b必须出现两次；类似地，D必须出现两次，C也一样。因此，在一系列八个字母中，代表通过七座桥的路径，字母A必须出现三次，字母B、C和D各出现两次——但这不能在八个字母的序列中出现（$3+2+2+2&gt;8$）。因此，这样的旅程不能跨越柯尼斯堡的七座桥。</p><p>更进一步，只要通往每个区域的桥梁数量是奇数，无论桥梁如何布置，都可以判断不可能一次旅行穿越每座桥梁而不重复。因为要满足条件的话所有字母必须出现的次数之和比桥的数量多一个，然而，像我们的例子中所发生的那样，事实上需要字母出现的数量大于桥梁的数量加一，那么这样的旅程永远无法完成。</p><h4 id="怎样才会存在？"><a href="#怎样才会存在？" class="headerlink" title="怎样才会存在？"></a>怎样才会存在？</h4><p>如果通向 A 的桥的数目是偶数，那么就必须考虑是否在 A 地出发</p><blockquote><p>比如有两座桥 a、b 连接 A、B，那么在 A 出发的路径可以是 A B A ，否则是 B A B</p></blockquote><p>如果有<strong>四座</strong>桥通向A，如果旅行者从A出发，那么在整个旅程中，如果他要穿过每座桥一次，字母A必须出现三次；如果他在另一个区域开始行走，那么字母A将出现<strong>两次</strong>。</p><p>如果有<strong>六座</strong>桥通向A，如果旅程从A开始，那么字母A将出现<strong>四次</strong>；如果旅行者没有从A开始，那么字母A只出现<strong>三次</strong>。</p><p>所以，<strong>一般来说</strong>，如果桥的数量是偶数，那么如果行程不是从A开始，A的出现次数将是这个数字的一半，如果行程从A开始，A的出现次数将比桥的一半多一个。</p><p>由于在任何旅程中，一个人只能从一个区域出发。这样就可以根据通往每个区域的桥梁数量，确定表示该区域的字母出现的数量。如果桥梁数量为奇数，为桥梁数量的一半加一；如果桥梁数量为偶数，则为其一半。最后，如果所有事件的总数等于桥的数量加上一，那么满足要求的行程将是可能的，并且必须从一个有奇数座桥通往它的区域开始。当然，如果得到的字母总数比桥梁数加一小一，那么旅程可以从一个桥梁数为偶数的区域开始，这样字母数将因此增加一。</p><blockquote><p>请注意，欧拉对“表示该区域的字母出现次数”的定义取决于通向每个区域（顶点）的桥（边）的数量是偶数还是奇数。在当代图论术语中，入射到顶点$V$上的边数被称为顶点$v$的“度”。</p></blockquote><p>因此，无论给出了什么样的桥梁布置，欧拉给出的以下方法将确定是否可以穿过每座桥梁：</p><ul><li><p>首先用字母 A、B、C 等表示被水隔开的各个区域。</p></li><li><p>然后，取桥的总数加上一，把结果写在下面的工作上面。</p></li><li><p>第三，把字母A、B、C等写在一列中，并在每一个旁边写下通向它的桥梁的数量。</p></li><li><p>第四，用星号表示那些有偶数桥的字母。</p></li><li><p>第五，在每一个偶数旁边写下一半的数字，在每一个奇数旁边写下一半的数字加一。</p></li><li><p>第六，把这些数字加起来，如果这个总和小于或等于上面写的数字，也就是桥的数量加上一，就得出结论，满足要求的旅程是可能的。</p><blockquote><p>必须记住，如果总和比上面写的数字小一，那么旅程必须从标有星号的区域之一开始，如果总和相等，则必须从未标有星号的区域开始。</p></blockquote><p>柯尼斯堡镇七桥问题的求解：</p><p>七座桥，$7+1&#x3D;8$</p><table><thead><tr><th align="center">地区</th><th align="center">相邻桥数</th><th align="center">通过地区次数</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">5</td><td align="center">3</td></tr><tr><td align="center">B</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">D</td><td align="center">3</td><td align="center">2</td></tr></tbody></table><p>显然 $3+2+2+2&gt;8$ 不满足题设</p></li></ul><p>再举一个例子，假设有如下图的排布</p><p><img src="/../images/%E4%B8%80%E7%AC%94%E7%94%BB%E7%9A%84%E8%83%8C%E5%90%8E/15bridge.png" alt="15桥"></p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">16</th></tr></thead><tbody><tr><td align="center">A*</td><td align="center">8</td><td align="center">4</td></tr><tr><td align="center">B*</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">C*</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">D*</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">E</td><td align="center">5</td><td align="center">3</td></tr><tr><td align="center">F*</td><td align="center">6</td><td align="center">3</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">16</td></tr></tbody></table><p>按照上述规则，我们可以找到如下路径：</p><p>​        <strong>EaFbBcFdAeFfCgAhCiDkAmEnApBoEiD</strong></p><p>这就是本题中的“欧拉路径”</p><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>尽管上述方法已经可以在复杂的情况下找到欧拉路径（如果存在的话），但欧拉并没有止步于此，他找到了一种更抽象更简洁的方法来表达这一思想。</p><p>首先，观察到字母A、B、C等旁边写的桥的数量加起来是桥总数的两倍。原因是，在计算中，每一座通往某一特定区域的桥梁都会被计算两次，每一座桥梁连接的两个区域各计算一次。</p><p>因此，通往每个区域的桥梁总数必须为偶数（其一半等于桥梁数量）。进一步，字母A、B、C等的一些桥的数量中只有一个是奇数，或者三个是奇数，或者五个，等等，这是不可能的。因此，如果字母A、B、C等的一些桥的数量是奇数，那么这些区域的数量一定是偶数。</p><blockquote><p>在七桥问题中，字母A、B、C和D都有奇数个桥相邻，在最后一个例子中，只有两个数字是奇数，即D和E。</p></blockquote><p>上述结果也被称为“握手定理”，源于计算社交聚会期间发生的握手次数的等效问题。在社交聚会上，每个在场的人与其他在场的人握手一次。握手定理的现代表述是：“<strong>有限图中所有顶点的度之和等于图中边数的两倍。</strong>” 或 “<strong>每个有限图包含偶数个奇数度的顶点。</strong>”</p><p>由于字母 A、B、C 等所相邻的桥数的总和等于桥数的两倍。很明显，如果该总和增加2，然后再除以2，将得到我们所想要的数字（桥数加一）。因此，如果字母 A、B、C 等的所有数字（第二列）都是偶数，并且取其中的一半来获得第三列中的数字，那么这些数字的总和将比上面写的数字（桥数加一）少一个，而我们开始行走的地方需要加一，则无论是什么地方开始旅程，都可以找到符合要求的路径。在七桥问题中，如果旅行者两次穿过每座桥，就会发生这种情况（每座桥都可以被视为不同的两座）。</p><p>此外，如果字母 A、B、C 等所相邻的桥数中只有两个是奇数，其余的是偶数，那么，如果旅程从一个有奇数座桥梁通往的区域开始，那么得到符合条件的路径是可能的。因为，如果偶数减半，奇数增加一，它们的一半之和将比桥的数量大一，因此等于上面写的数字。从这可以进一步看出，如果有四，六，八……个奇数出现在第二列，那么第三列中的数字之和将比桥数大2，3，4……甚至更多。那么找到符合题设的路径将是不可能的。</p><p>至此，得到了为人们所熟知的结论，即：</p><blockquote><p>无论桥如何排列，如果有两个以上的地区有奇数座桥梁通往，那么找到符合要求的路径是不可能的。<br>如果恰好有两个区域的桥梁数量是奇数，那么如果从这两个区域中的任何一个开始，找到符合要求的路径都是可能的。<br>如果没有奇数座桥梁通往的区域，那么可以从任何区域开始完成所需的旅程。</p></blockquote><h3 id="找到路径！"><a href="#找到路径！" class="headerlink" title="找到路径！"></a>找到路径！</h3><p>如果知道了在合适条件下必然存在符合题设路径，如何找到呢？ 关于这个问题，欧拉给出了答案（给了，但是又没给hhh）</p><p>欧拉原话：</p><blockquote><p>I do not therefore think it worthwhile to give any further details concerning the ﬁnding of the routes.</p></blockquote><p>理由是对于一个区域，我们可以成对的忽视桥梁，这样结构就被大大简化，所以便可以轻而易举的找到路径。</p><h3 id="现代表述"><a href="#现代表述" class="headerlink" title="现代表述"></a>现代表述</h3><p>要得到欧拉主要结果的完整现代陈述，我们需要几个定义</p><p>连通：</p><blockquote><p>对于图 G 的两个顶点 u 和 v ，如果在中存在一条路，记为 (u,v) 路，则称 u 和 v 是连通的。如果图 G 不连通，则它每一个分支是连通的</p></blockquote><p>根据这一定义，Euler论文的主要结果如下：</p><h5 id="Theorem：有限图G包含Euler回路当且仅当G是连通的且不包含奇数度顶点。"><a href="#Theorem：有限图G包含Euler回路当且仅当G是连通的且不包含奇数度顶点。" class="headerlink" title="Theorem：有限图G包含Euler回路当且仅当G是连通的且不包含奇数度顶点。"></a>Theorem：有限图G包含Euler回路当且仅当G是连通的且不包含奇数度顶点。</h5><h5 id="Corollary：有限图G包含Euler路径当且仅当G是连通的且至多包含两个奇数度顶点。"><a href="#Corollary：有限图G包含Euler路径当且仅当G是连通的且至多包含两个奇数度顶点。" class="headerlink" title="Corollary：有限图G包含Euler路径当且仅当G是连通的且至多包含两个奇数度顶点。"></a>Corollary：有限图G包含Euler路径当且仅当G是连通的且至多包含两个奇数度顶点。</h5><p>当然，欧拉的证明与现代证明有所不同，但欧拉的这项工作为几何学特别是图论翻开了新的一页。</p><p>就这样，<em><strong>是否可以不重复的走遍七座桥</strong></em> 这样一个看似“没啥用”的问题，经过百年的发展，如今成为了可以许多学科问题的便利工具。</p><p>所以，多做点“没用的事”，挺好。</p>]]></content>
    
    
    <summary type="html">数学让我们超越人类直觉，使我们能够探索人类无法触及的领域</summary>
    
    
    
    <category term="拓扑学/图论" scheme="http://wonderland.plus/categories/%E6%8B%93%E6%89%91%E5%AD%A6-%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="图论" scheme="http://wonderland.plus/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼无人机的最基础</title>
    <link href="http://wonderland.plus/posts/4179/"/>
    <id>http://wonderland.plus/posts/4179/</id>
    <published>2022-03-29T09:13:40.000Z</published>
    <updated>2022-04-02T14:05:48.500Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="四旋翼无人机"><a href="#四旋翼无人机" class="headerlink" title="四旋翼无人机"></a>四旋翼无人机</h1><h2 id="三系统"><a href="#三系统" class="headerlink" title="三系统"></a>三系统</h2><h3 id="动力系统"><a href="#动力系统" class="headerlink" title="动力系统"></a>动力系统</h3><ul><li><p>旋翼</p><p>伯努利原理、反扭矩</p></li><li><p>电机</p><p>可采用PWM控制的有刷电机</p></li><li><p>电池</p></li></ul><h3 id="飞控"><a href="#飞控" class="headerlink" title="飞控"></a>飞控</h3><p>姿态的  <strong>采集</strong>  <strong>解算</strong>  <strong>控制</strong> </p><ul><li><p>嵌入式系统</p></li><li><p>无线通信</p></li><li><p>姿态传感器</p><blockquote><p>卡尔曼滤波</p></blockquote></li><li><p>气压计</p></li></ul><h3 id="操控系统"><a href="#操控系统" class="headerlink" title="操控系统"></a>操控系统</h3><h2 id="动力原理"><a href="#动力原理" class="headerlink" title="动力原理"></a>动力原理</h2><h3 id="反扭矩"><a href="#反扭矩" class="headerlink" title="反扭矩"></a>反扭矩</h3><p>对角线上的旋翼同方向旋转，两条对角线上产生的扭矩相互抵消，使得飞机机身保持稳定。</p><h3 id="六自由度运动"><a href="#六自由度运动" class="headerlink" title="六自由度运动"></a>六自由度运动</h3><h5 id="直线运动"><a href="#直线运动" class="headerlink" title="直线运动"></a>直线运动</h5><p>X、Y、Z三轴</p><h5 id="角运动"><a href="#角运动" class="headerlink" title="角运动"></a>角运动</h5><p>俯仰、滚转、偏航</p><h5 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h5><p>$f_1$ 、$f_2$ 、$f_3$ 、 $f_4$ 四个旋翼产生的升力控制飞机姿态</p><ul><li>$f_1$ + $f_2$ $\ne$ $f_3$ + $f_4$  控制俯仰 <strong>Pitch</strong></li><li>$f_1$ + $f_3$ $\ne$ $f_2$ + $f_4$  控制偏航 <strong>Yaw</strong></li><li>$f_2$ + $f_3$ $\ne$ $f_1$ + $f_4$ 控制滚转 <strong>Rool</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="嵌入式开发" scheme="http://wonderland.plus/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="UAV" scheme="http://wonderland.plus/tags/UAV/"/>
    
  </entry>
  
  <entry>
    <title>ARKit基础之位置追踪</title>
    <link href="http://wonderland.plus/posts/6421/"/>
    <id>http://wonderland.plus/posts/6421/</id>
    <published>2022-03-29T09:05:12.000Z</published>
    <updated>2022-04-02T14:05:48.491Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="位置追踪"><a href="#位置追踪" class="headerlink" title="位置追踪"></a>位置追踪</h2><h3 id="SLAM"><a href="#SLAM" class="headerlink" title="SLAM"></a>SLAM</h3><blockquote><p>即Simultaneous Localization And Mapping ，即时定位与建图。</p></blockquote><h4 id="定位与定姿"><a href="#定位与定姿" class="headerlink" title="定位与定姿"></a>定位与定姿</h4><p>主要采用<strong>视觉惯性里程计(VIO)<strong>和</strong>惯性导航系统</strong> </p><blockquote><p>VIO: Visual Inertial Odomentry</p></blockquote><p>综合使用VIO与惯性导航可以实时追踪用户的位置。VIO在刷新帧之间计算用户的位置<em>每秒30次以上，并行计算两次，至少以保证流畅</em> 。VIO与惯性导航系统并行计算，计算完成后使用卡尔曼滤波或者非线性优化等手段结合两个系统结过给出最终结果。</p><blockquote><p>6DOF为X、Y、Z加上俯仰、偏转、翻滚</p></blockquote><blockquote><p>惯性检测单元（IMU）：加速度计和陀螺仪</p></blockquote><table><thead><tr><th>惯性导航系统优点</th><th>精度高，每秒1000次运算</th></tr></thead><tbody><tr><td>惯性导航系统缺点</td><td>随与视觉系统复位时间而降低精度</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="iOS开发" scheme="http://wonderland.plus/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="ARKit" scheme="http://wonderland.plus/tags/ARKit/"/>
    
  </entry>
  
  <entry>
    <title>ARKit基础</title>
    <link href="http://wonderland.plus/posts/13868/"/>
    <id>http://wonderland.plus/posts/13868/</id>
    <published>2022-03-29T07:43:06.000Z</published>
    <updated>2022-04-02T14:05:48.489Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ARKit-基础"><a href="#ARKit-基础" class="headerlink" title="ARKit 基础"></a>ARKit 基础</h1><h4 id="ARKit-x3D-AVFoundation-CoreMotion-CoreML"><a href="#ARKit-x3D-AVFoundation-CoreMotion-CoreML" class="headerlink" title="ARKit &#x3D; AVFoundation + CoreMotion + CoreML"></a>ARKit &#x3D; AVFoundation + CoreMotion + CoreML</h4><h4 id="图像-x2F-3D检测识别跟踪、人脸遮挡OK-、同时开前后摄像头、多人协作、"><a href="#图像-x2F-3D检测识别跟踪、人脸遮挡OK-、同时开前后摄像头、多人协作、" class="headerlink" title="图像&#x2F;3D检测识别跟踪、人脸遮挡OK?、同时开前后摄像头、多人协作、"></a>图像&#x2F;3D检测识别跟踪、人脸遮挡OK?、同时开前后摄像头、多人协作、</h4><h4 id="景深、地理位置锚点"><a href="#景深、地理位置锚点" class="headerlink" title="景深、地理位置锚点"></a>景深、地理位置锚点</h4><h4 id="不包含图形渲染API，使用RealityKit、SceneKit、SpriteKit、Metal等"><a href="#不包含图形渲染API，使用RealityKit、SceneKit、SpriteKit、Metal等" class="headerlink" title="不包含图形渲染API，使用RealityKit、SceneKit、SpriteKit、Metal等"></a>不包含图形渲染API，使用RealityKit、SceneKit、SpriteKit、Metal等</h4><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li>在运动中做运动跟踪</li><li>跟踪动态环境（湖面）</li><li>热漂移（手机升温）</li><li>昏暗环境</li></ul><h3 id="ARSession"><a href="#ARSession" class="headerlink" title="ARSession"></a>ARSession</h3><h5 id="管理AR应用的状态和整个生命周期，ARKit-API-的主要入口"><a href="#管理AR应用的状态和整个生命周期，ARKit-API-的主要入口" class="headerlink" title="管理AR应用的状态和整个生命周期，ARKit API 的主要入口"></a>管理AR应用的状态和整个生命周期，ARKit API 的主要入口</h5><h3 id="ARAnchor（AR锚点）"><a href="#ARAnchor（AR锚点）" class="headerlink" title="ARAnchor（AR锚点）"></a>ARAnchor（AR锚点）</h3><h5 id="无法添加虚拟元素"><a href="#无法添加虚拟元素" class="headerlink" title="无法添加虚拟元素"></a>无法添加虚拟元素</h5><h5 id="将虚拟物体固定到AR场景中"><a href="#将虚拟物体固定到AR场景中" class="headerlink" title="将虚拟物体固定到AR场景中"></a>将虚拟物体固定到AR场景中</h5><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><h5 id="视觉校准技术，使锚点姿态不随着时间变化"><a href="#视觉校准技术，使锚点姿态不随着时间变化" class="headerlink" title="视觉校准技术，使锚点姿态不随着时间变化"></a>视觉校准技术，使锚点姿态不随着时间变化</h5><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><h5 id="1-在可跟踪对象上（平面、人脸等）创建锚点"><a href="#1-在可跟踪对象上（平面、人脸等）创建锚点" class="headerlink" title="1. 在可跟踪对象上（平面、人脸等）创建锚点"></a>1. 在可跟踪对象上（平面、人脸等）创建锚点</h5><h5 id="2-将虚拟物体链接到锚点"><a href="#2-将虚拟物体链接到锚点" class="headerlink" title="2. 将虚拟物体链接到锚点"></a>2. 将虚拟物体链接到锚点</h5><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><ul><li>虚拟物体“焊接”到某物体上</li><li>姿态不变</li><li>几个虚拟物体相对位置不变、独立性</li><li>提高跟踪性</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>尽可能重复使用锚点（独立锚点的对象可以 平移&#x2F;旋转）</li><li>保持物体靠近锚点（1m）</li><li>分离未使用的锚点</li></ul><h4 id="种类："><a href="#种类：" class="headerlink" title="种类："></a>种类：</h4><ul><li>ARPlaneAnchor     平面</li><li>ARImageAnchor 2D图像</li><li>ARObjectAnchor 3D物体</li><li>ARFaceAnchor     人脸（姿态、表情）</li><li>ARBodyAnchor    人体</li><li>ARParticeipantAnchor  多人共享的</li><li>AREnvironmentProbeAnchor  环境光探头</li><li>ARMeshAnchor  使用LiDAR重建场景的场景网格的Anchor</li><li>ARGeoAnchor 地理位置信息</li></ul><h3 id="ARFrame（AR帧）"><a href="#ARFrame（AR帧）" class="headerlink" title="ARFrame（AR帧）"></a>ARFrame（AR帧）</h3><h5 id="相比于视频流包含了与AR有关的参数"><a href="#相比于视频流包含了与AR有关的参数" class="headerlink" title="相比于视频流包含了与AR有关的参数"></a>相比于视频流包含了与AR有关的参数</h5><h3 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h3><h5 id="专为AR设计"><a href="#专为AR设计" class="headerlink" title="专为AR设计"></a>专为AR设计</h5><h4 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h4><ul><li>渲染（反射、阴影）</li><li>动画（骨骼&#x2F;变换 动画）</li><li>物理仿真</li><li>网络同步：整合了近距离通信框架</li><li>实体组件：避免了多继承（swift不支持）的维护问题</li><li>3D音效</li><li>其他很多功能自动处理</li></ul><h4 id="体系架构："><a href="#体系架构：" class="headerlink" title="体系架构："></a>体系架构：</h4><ul><li>ARView<ul><li>将渲染场景呈现给用户的一个窗口</li><li>都包含Scene实例</li><li>处理输入交互</li></ul></li><li>Scene<ul><li>放置实体对象的容器</li><li>创建ARView时自动创建</li><li>可通过ARView的属性访问</li></ul></li><li>AnchorEntity<ul><li>继承自Entity类</li><li>挂载了AnchorComponent组件</li></ul></li><li>Entity<ul><li>AR应用最基本组成元素</li><li>遵循Component协议、包含components集合，用于挂在各类组件</li><li>层次结构可以保存到文件中</li><li>预定义了8类实体</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="iOS开发" scheme="http://wonderland.plus/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="ARKit" scheme="http://wonderland.plus/tags/ARKit/"/>
    
  </entry>
  
  <entry>
    <title>开篇</title>
    <link href="http://wonderland.plus/posts/35811/"/>
    <id>http://wonderland.plus/posts/35811/</id>
    <published>2022-03-29T07:23:07.000Z</published>
    <updated>2022-04-02T14:05:48.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><p>没啥好说的，所以就不说。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="杂" scheme="http://wonderland.plus/tags/%E6%9D%82/"/>
    
  </entry>
  
</feed>
